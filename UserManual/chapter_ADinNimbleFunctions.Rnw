%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr

\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Using automatic differentiation in nimbleFunctions}
\label{cha:AD-in-nimble}

%<<echo=FALSE>>=
%read_chunk(file.path('chunks', 'programmingWithModels_chunks.R')) 
%@ 

Before using derivatives in nimble, you must set \cd{nimbleOptions(experimentalEnableDerivs = TRUE)} in your R session. Derivatives of functions in nimble are obtained by using the \cd{nimDerivs()} function.  Currently, `nimDerivs()` can be used to take derivatives of:

\begin{itemize}
	\item Calls to \cd{model\$calculate(nodes)}
	\item Calls to methods of \cd{nimbleFunction}s
\end{itemize}

We'll start by describing the arguments to the \cd{nimDerivs()} function.  Then we'll give an example of each of these two uses of \cd{nimDerivs()}.

\section{The \cd{nimDerivs()} function}

The \cd{nimDerivs()} function takes the following arguments:

\begin{itemize}

 \item \cd{nimFxn}: This will be either a call to a \cd{nimbleFunction} method, with arguments included, or a call to \cd{model\$calculate(nodes)}.

 \item \cd{order}: an integer vector with values within the set $\{0, 1, 2\}$, corresponding to whether the function value, Jacobian, and Hessian should be returned respectively.  Defaults to \cd{c(0, 1, 2)}.

 \item \cd{wrt} a character vector of either: names of function arguments (if taking derivatives of a \cd{nimbleFunction} method), or node names (if taking derivatives of \cd{model\$calculate(nodes)}), naming the variables to take derivatives with respect to.  If not specified, derivatives will be taken with respect to all function arguments, if taking derivatives of a nimbleFunction, or all node arguments, if taking derivatives of a call to \cd{model\$calculate(nodes)}.

\end{itemize}

\cd{nimDerivs()} returns a \cd{nimbleList} object of type \cd{ADnimbleList}, which contains three elements:

\begin{itemize}
	\item \cd{value}: The value of the function, evaluated at the current argument values.  This element is stored as a \cd{double(1)} type, even if the value returned from the function is a scalar.  The \code{value} element of the \cd{nimbleList} will only be populated if \cd{0} was included in the \cd{order} argument to \cd{nimDerivs}.
	\item \cd{jacobian} A matrix of first derivatives of the function, with respect to the \code{wrt} argument, evaluated at the current argument values.  This matrix is stored as a \cd{double(2)} type.  The rows of the \code{jacobian} matrix correspond to the elements of the function's return value, while the columns correspond to the elements of the \code{wrt} argument.  For example, the value in the $i$th row and $j$th column will represent the $i$th element of the derivative of the function's return value with respect to the $j$th element of the \code{wrt} argument.   The \code{jacobian} element of the \cd{nimbleList} will only be populated if \cd{1} was included in the \cd{order} argument to \cd{nimDerivs}. 
	\item \cd{hessian} An array of second derivatives of the function, with respect to the \code{wrt} argument, evaluated at the current argument values.  This element is stored as a \cd{double(3)} type.  
	The first two dimensions of the \code{hessian} array correspond, respectively, to the two elements of the \code{wrt} argument that the second derivative is taken with respect to.  The third dimension of the \code{hessian} array corresponds to the elements of the return value.  For example, the $(i, j, k)$ element of the \code{hessian} array corresponds to the $k$th element of the second derivative with respect to the $i$th and $j$th elements of the \code{wrt} argument.  The \code{hessian} element of the \cd{nimbleList} will only be populated if \cd{2} was included in the \cd{order} argument to \cd{nimDerivs}.    
\end{itemize}

For matrix valued \code{wrt} arguments or return values, elements are arranged in column-major order.  For example, suppose we take derivatives of a scalar-valued function with respect to a \code{2\times2} matrix argument \code{x}.   The \code{jacobian} element of the returned \cd{ADnimbleList} will be a \cd{1\times4} matrix, where  \code{jacobian[1,1]} will be the derivative of the function with respect to \cd{x[1,1]}, 
\code{jacobian[1,2]} will be the derivative of the function with respect to \cd{x[2,1]}, \code{jacobian[1,3]} will be the derivative of the function with respect to \cd{x[1,2]}, and \code{jacobian[1,4]} will be the derivative of the function with respect to \cd{x[2,2]}.

We note that if only the \cd{jacobian} or \cd{hessian} are needed in your \cd{nimbleFunction}, setting \cd{order = 1} or \cd{order = 2}, respectively, will 

\subsection{Example of calling \cd{nimDerivs(model\$calculate(nodes))}}

We'll demonstrate taking derivatives of calls \cd{model\$calculate(nodes)}.  First we'll build a very simple model, and then take derivatives of its log probability calculation.

First we build the model:

<<nimbleADmodelCode, message=FALSE>>=
nimbleOptions(experimentalEnableDerivs = TRUE)

simpleCode <- nimbleCode({
	x ~ dnorm(0, 1)
	y ~ dnorm(x, 1)
})
simpleModel <- nimbleModel(code = simpleCode, data = list(y = 0), 
inits = list(x = 1))
compileNimble(simpleModel)
@

Next we'll create a \cd{nimbleFunction} that will take derivatives of the model's \cd{calculate} function.

<<nimbleADcalculateCode, message=FALSE>>=
returnDerivsFunction <- nimbleFunction(
	setup = function(model){
	},
	run = function(){
		outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x')
		returnType(ADNimbleList())
		return(outDerivsList)
	}
)
@

Recall that a \cd{nimbleList} of type \cd{ADNimbleList} is returned from a call to \cd{nimDerivs}, so \cd{returnType(ADNimbleList())} must be specified if we want the list to be returned from our function.  
Derivatives can then be obtained by:

<<nimbleADcalculateDerivs, message=FALSE>>=
returnDerivsSimpleModel <- returnDerivsFunction(simpleModel)
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
derivsList <-  CreturnDerivsSimpleModel$run()
derivsList$jacobian ## examine jacobian matrix
@

\subsection{Example of calling \cd{nimDerivs} for a \cd{nimbleFunction} method}

Now, suppose we have a method of a \cd{nimbleFunction} we wish to take derivatives of.  For example, consider the \cd{nimbleFunction} given below, where we wish to take derivatives of the \cd{derivMethod} method:

<<nimbleADfunction, message=FALSE>>=
testDerivs <- nimbleFunction(
	setup = function(){
	},
	run = function(a = double(0), bMatrix = double(2)){
		outHessian <- nimDerivs(derivMethod(a, bMatrix), wrt = 'x', order = 2)$hessian
		returnType(double(3))
		return(outHessian)
	},
	methods = list(
		derivMethod = function(x = double(0), y = double(2, c(3, 5))){
			outVector <- x^2*y[1,]
			returnType(double(1, 5))
			return(outVector)
		}
	),
	enableDerivs = c('derivMethod')
)
@

Any \cd{nimbleFunction} method that we wish to take derivatives of must accept only \cd{double} arguments, and must have a \cd{double} \cd{returnType}.  Additionally, the size of all arguments and return values must be explicitly declared.  For example, the \cd{y} argument is explicitly declared as a $3\times5$ matrix, and a length 5 vector is explicitly returned.

Additionally, any \cd{nimbleFunction} method that we wish to take derivatives of must be named in the \cd{enableDerivs} argument to \cd{nimbleFunction()}.  Below, we compile and run our \cd{nimbleFunction}.

<<nimbleADfunctionRun, message=FALSE>>=
testDerivsFunction <- testDerivs()
CtestDerivsFunction <-  compileNimble(testDerivsFunction)
CtestDerivsFunction$run(3.14, 1:5)
@

\subsection{Warnings about AD in nimbleFunction methods}

As a result of using the \textbf{cppad} package to calculate derivatives of functions in nimble, there are a few aspects of nimble's DSL that do not currently function correctly while taking derivatives.

\begin{itemize}
	\item \textbf{\cd{if} statements}: \cd{if(logicalExpression){...}} statements will not work correctly in a function that is having its derivative taken.  \cd{while(logicalExpression)} statements should similarly not work correctly.
	\begin{itemize}
		\item \textbf{Current behavior}:  Rather than re-evaluate the value of the \cd{logicalExpression} each time the \cd{if} statement is encountered, the value of \cd{logicalExpressions} (either \cd{TRUE} or \cd{FALSE}) is frozen after the first time it is evaluated (when the tape is first created).
		\item \textbf{Potential solution}: The use of \cd{condExp} statements from the \textbf{cppad} package will allow for simple logical expressions of the form \cd{if(a>b) c; else d;}.  This should enable, e.g., truncated distributions.    
	\end{itemize}  
  \item \textbf{Indexing using arguments to an AD enabled function}:  Suppose a derivative enabled function has two arguments: \cd{x}, a vector (or matrix, array, ...), and \cd{y}, a scalar.  If at some point in the code, you wish to index \cd{x} using \cd{y} (e.g. \cd{x[y]}), this indexing will not retrieve the correct value of \cd{x}.
  \begin{itemize}
  	\item \textbf{Current behavior}: Similar to the \cd{if} statement behavior above, the value of \cd{x[y]} in the function will be frozen at the value \cd{x[y0]}, where \cd{y0} is the value of \cd{y} used when the tape is first created.
  	\item \textbf{Potential solution}: Use of \cd{VecAD} objects from the \textbf{cppad} package.  Representing arguments to derivative-enabled nimbleFunctions using \cd{VecAD} objects allows these arguments to be correctly indexed using other arguments.  We note, according to the \textbf{cppad} documentation, that the \cd{VecAD} type is known to be inefficient as compared to standard vector objects, so ideally \cd{VecAD} would only be used when necessary.
\end{itemize}
\item \textbf{\cd{for} loop extents}: If the AD enabled function contains a \cd{for} loop, where the extent of the \cd{for} loop is an argument to the function, e.g. \code{for(i in 1:x)} with \cd{x} an argument, the extent of the \cd{for} loop will not correctly be re-evaluated when new values of \cd{x} are given to the function.
  \begin{itemize}
  	\item \textbf{Potential solution}: I don't think \textbf{cppad} has a pre-made solution for this problem.  One option would be to re-tape every time a new value of \cd{x} is detected, but this would be inefficient.  Another option could involve the use of \cd{condExp} statements, although the specifics of this are not clear at the moment.  
  \end{itemize}
\item \textbf{Objects created in \cd{setup} code}:  Currently, objects created in \cd{setup} code of a nimbleFunction cannot be used within AD enabled methods.  
  \begin{itemize}
	\item \textbf{Potential solution}: I think that a (probably not too difficult) modification to the tape creation and argument transfer functions could insert current values of \cd{setup} code objects into the tape, allowing the calculation to proceed correctly.  I think we'd need to be careful when adding these additional ``independent variables'' to the tape, as they could disrupt the order of the \cd{wrt} arguments, which would lead to incorrect output from calls to \cd{nimDerivs}.  This modification could also (if anyone would use it) potentially allow for derivatives to be taken with respect to \cd{setup} code objects, in addition to nimbleFunction method arguments.
\end{itemize}
\end{itemize}

\subsection{Additional warnings about AD in nimbleModels}
The following distributions are known to not work (currently) in AD-enabled models in nimble:
  \begin{itemize}
  	\item \cd{dcat}: requires a fix to the indexing argument problem mentioned in the previous section.
  	\item \cd{dmulti}:  I could be wrong here, but I'm not sure if it makes sense to take derivatives w.r.t. any parameters of this distribution.  The only non-discrete parameter is \code{prob}, but since the elements of \code{prob} must sum to 1, I'm not clear on whether a derivative w.r.t e.g. \code{prob[1]} makes sense.
  	\item \cd{dmnorm_chol}: for this, and other distributions which take Cholesky decompositions of covariance matrices as arguments, it seems as though taking derivatives w.r.t. elements of the Cholesky decomposition doesn't make sense.