%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr

\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Using automatic differentiation in nimbleFunctions}
\label{cha:AD-in-nimble}

%<<echo=FALSE>>=
%read_chunk(file.path('chunks', 'programmingWithModels_chunks.R')) 
%@ 

Before using derivatives in nimble, you must set \cd{nimbleOptions(experimentalEnableDerivs = TRUE)} in your R session. Derivatives of functions in nimble are obtained by using the \cd{nimDerivs()} function.  Currently, `nimDerivs()` can be used to take derivatives of:

\begin{itemize}
	\item Calls to \cd{model\$calculate(nodes)}
	\item Calls to methods of \cd{nimbleFunction}s
\end{itemize}

We'll start by describing the arguments to the \cd{nimDerivs()} function.  Then we'll give an example of each of these two uses of \cd{nimDerivs()}.

\section{The \cd{nimDerivs()} function}

The \cd{nimDerivs()} function takes the following arguments:

\begin{itemize}

 \item \cd{nimFxn}: This will be either a call to a \cd{nimbleFunction} method, with arguments included, or a call to \cd{model\$calculate(nodes)}.

 \item \cd{order}: an integer vector with values within the set $\{0, 1, 2\}$, corresponding to whether the function value, Jacobian, and Hessian should be returned respectively.  Defaults to \cd{c(0, 1, 2)}.

 \item \cd{wrt} a character vector of either: names of function arguments (if taking derivatives of a \cd{nimbleFunction} method), or node names (if taking derivatives of \cd{model\$calculate(nodes)}), naming the variables to take derivatives with respect to.  If not specified, derivatives will be taken with respect to all function arguments, if taking derivatives of a nimbleFunction, or all node arguments, if taking derivatives of a call to \cd{model\$calculate(nodes)}.

\end{itemize}

\cd{nimDerivs()} returns a \cd{nimbleList} object of type \cd{ADnimbleList}, which contains three elements:

\begin{itemize}
	\item \cd{value}: The value of the function, evaluated at the current argument values.  This element is stored as a \cd{double(1)} type, even if the value returned from the function is a scalar.  The \code{value} element of the \cd{nimbleList} will only be populated if \cd{0} was included in the \cd{order} argument to \cd{nimDerivs}.
	\item \cd{jacobian} A matrix of first derivatives of the function, with respect to the \code{wrt} argument, evaluated at the current argument values.  This matrix is stored as a \cd{double(2)} type.  The rows of the \code{jacobian} matrix correspond to the elements of the function's return value, while the columns correspond to the elements of the \code{wrt} argument.  For example, the value in the $i$th row and $j$th column will represent the $i$th element of the derivative of the function's return value with respect to the $j$th element of the \code{wrt} argument.   The \code{jacobian} element of the \cd{nimbleList} will only be populated if \cd{1} was included in the \cd{order} argument to \cd{nimDerivs}. 
	\item \cd{hessian} An array of second derivatives of the function, with respect to the \code{wrt} argument, evaluated at the current argument values.  This element is stored as a \cd{double(3)} type.  
	The first two dimensions of the \code{hessian} array correspond, respectively, to the two elements of the \code{wrt} argument that the second derivative is taken with respect to.  The third dimension of the \code{hessian} array corresponds to the elements of the return value.  For example, the $(i, j, k)$ element of the \code{hessian} array corresponds to the $k$th element of the second derivative with respect to the $i$th and $j$th elements of the \code{wrt} argument.  The \code{hessian} element of the \cd{nimbleList} will only be populated if \cd{2} was included in the \cd{order} argument to \cd{nimDerivs}.    
\end{itemize}

For matrix valued \code{wrt} arguments or return values, elements are arranged in column-major order.  For example, suppose we take derivatives of a scalar-valued function with respect to a \code{2\times2} matrix argument \code{x}.   The \code{jacobian} element of the returned \cd{ADnimbleList} will be a \cd{1\times4} matrix, where  \code{jacobian[1,1]} will be the derivative of the function with respect to \cd{x[1,1]}, 
\code{jacobian[1,2]} will be the derivative of the function with respect to \cd{x[2,1]}, \code{jacobian[1,3]} will be the derivative of the function with respect to \cd{x[1,2]}, and \code{jacobian[1,4]} will be the derivative of the function with respect to \cd{x[2,2]}.

We note that if only the \cd{jacobian} or \cd{hessian} are needed in your \cd{nimbleFunction}, setting \cd{order = 1} or \cd{order = 2}, respectively, will 

\subsection{Example of calling \cd{nimDerivs(model\$calculate(nodes))}}

We'll demonstrate taking derivatives of calls \cd{model\$calculate(nodes)}.  First we'll build a very simple model, and then take derivatives of its log probability calculation.

First we build the model:

<<nimbleADmodelCode, message=FALSE>>=
nimbleOptions(experimentalEnableDerivs = TRUE)

simpleCode <- nimbleCode({
	x ~ dnorm(0, 1)
	y ~ dnorm(x, 1)
})
simpleModel <- nimbleModel(code = simpleCode, data = list(y = 0), 
inits = list(x = 1))
compileNimble(simpleModel)
@

Next we'll create a \cd{nimbleFunction} that will take derivatives of the model's \cd{calculate} function.

<<nimbleADcalculateCode, message=FALSE>>=
returnDerivsFunction <- nimbleFunction(
	setup = function(model){
	},
	run = function(){
		outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x')
		returnType(ADNimbleList())
		return(outDerivsList)
	}
)
@

Recall that a \cd{nimbleList} of type \cd{ADNimbleList} is returned from a call to \cd{nimDerivs}, so \cd{returnType(ADNimbleList())} must be specified if we want the list to be returned from our function.  
Derivatives can then be obtained by:

<<nimbleADcalculateDerivs, message=FALSE>>=
returnDerivsSimpleModel <- returnDerivsFunction(simpleModel)
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
derivsList <-  CreturnDerivsSimpleModel$run()
derivsList$jacobian ## examine jacobian matrix
@

\subsection{Example of calling \cd{nimDerivs} for a \cd{nimbleFunction} method}

Now, suppose we have a method of a \cd{nimbleFunction} we wish to take derivatives of.  For example, consider the \cd{nimbleFunction} given below, where we wish to take derivatives of the \cd{derivMethod} method:

<<nimbleADfunction, message=FALSE>>=
testDerivs <- nimbleFunction(
	setup = function(){
	},
	run = function(a = double(0), bMatrix = double(2)){
		outHessian <- nimDerivs(derivMethod(a, bMatrix), wrt = 'x', order = 2)$hessian
		returnType(double(3))
		return(outHessian)
	},
	methods = list(
		derivMethod = function(x = double(0), y = double(2, c(3, 5))){
			outVector <- x^2*y[1,]
			returnType(double(1, 5))
			return(outVector)
		}
	),
	enableDerivs = c('derivMethod')
)
@

Any \cd{nimbleFunction} method that we wish to take derivatives of must accept only \cd{double} arguments, and must have a \cd{double} \cd{returnType}.  Additionally, the size of all arguments and return values must be explicitly declared.  For example, the \cd{y} argument is explicitly declared as a $3\times5$ matrix, and a length 5 vector is explicitly returned.

Additionally, any \cd{nimbleFunction} method that we wish to take derivatives of must be named in the \cd{enableDerivs} argument to \cd{nimbleFunction()}.  Below, we compile and run our \cd{nimbleFunction}.

<<nimbleADfunctionRun, message=FALSE>>=
testDerivsFunction <- testDerivs()
CtestDerivsFunction <-  compileNimble(testDerivsFunction)
CtestDerivsFunction$run(3.14, 1:5)
@

\subsection{Warnings about AD in nimbleFunction methods}

As a result of using the \textbf{cppad} package to calculate derivatives of functions in nimble, there are a few aspects of nimble's DSL that do not currently function correctly while taking derivatives.

\begin{itemize}
	\item \textbf{\cd{if} statements}: \cd{if(logicalExpression){...}} statements will not work correctly in a function that is having its derivative taken.  \cd{while(logicalExpression)} statements should similarly not work correctly.
	\begin{itemize}
		\item \textbf{Current behavior}:  Rather than re-evaluate the value of the \cd{logicalExpression} each time the \cd{if} statement is encountered, the value of \cd{logicalExpressions} (either \cd{TRUE} or \cd{FALSE}) is frozen after the first time it is evaluated (when the tape is first created).
		\item \textbf{Potential solution}: The use of \cd{condExp} statements from the \textbf{cppad} package will allow for simple logical expressions of the form \cd{if(a>b) c; else d;}.  This should enable, e.g., truncated distributions.    
	\end{itemize}  
  \item \textbf{Indexing using arguments to an AD enabled function}:  Suppose a derivative enabled function has two arguments: \cd{x}, a vector (or matrix, array, ...), and \cd{y}, a scalar.  If at some point in the code, you wish to index \cd{x} using \cd{y} (e.g. \cd{x[y]}), this indexing will not retrieve the correct value of \cd{x}.
  \begin{itemize}
  	\item \textbf{Current behavior}: Similar to the \cd{if} statement behavior above, the value of \cd{x[y]} in the function will be frozen at the value \cd{x[y0]}, where \cd{y0} is the value of \cd{y} used when the tape is first created.
  	\item \textbf{Potential solution}: Use of \cd{VecAD} objects from the \textbf{cppad} package.  Representing arguments to derivative-enabled nimbleFunctions using \cd{VecAD} objects allows these arguments to be correctly indexed using other arguments.  We note, according to the \textbf{cppad} documentation, that the \cd{VecAD} type is known to be inefficient as compared to standard vector objects, so ideally \cd{VecAD} would only be used when necessary.
\end{itemize}
\item \textbf{\cd{for} loop extents}: If the AD enabled function contains a \cd{for} loop, where the extent of the \cd{for} loop is an argument to the function, e.g. \code{for(i in 1:x)} with \cd{x} an argument, the extent of the \cd{for} loop will not correctly be re-evaluated when new values of \cd{x} are given to the function.
  \begin{itemize}
  	\item \textbf{Potential solution}: I don't think \textbf{cppad} has a pre-made solution for this problem.  One option would be to re-tape every time a new value of \cd{x} is detected, but this would be inefficient.  Another option could involve the use of \cd{condExp} statements, although the specifics of this are not clear at the moment.  
  \end{itemize}
\item \textbf{Objects created in \cd{setup} code}:  Currently, objects created in \cd{setup} code of a nimbleFunction cannot be used within AD enabled methods.  
  \begin{itemize}
	\item \textbf{Potential solution}: I think that a (probably not too difficult) modification to the tape creation and argument transfer functions could insert current values of \cd{setup} code objects into the tape, allowing the calculation to proceed correctly.  I think we'd need to be careful when adding these additional ``independent variables'' to the tape, as they could disrupt the order of the \cd{wrt} arguments, which would lead to incorrect output from calls to \cd{nimDerivs}.  This modification could also (if anyone would use it) potentially allow for derivatives to be taken with respect to \cd{setup} code objects, in addition to nimbleFunction method arguments.
\end{itemize}
\end{itemize}

\subsection{Additional warnings about AD in nimbleModels}
The following distributions are known to not work (currently) in AD-enabled models in nimble:
  \begin{itemize}
  	\item \cd{dcat}: requires a fix to the indexing argument problem mentioned in the previous section.
  	\item \cd{dmulti}:  I could be wrong here, but I'm not sure if it makes sense to take derivatives w.r.t. any parameters of this distribution.  The only non-discrete parameter is \code{prob}, but since the elements of \code{prob} must sum to 1, I'm not clear on whether a derivative w.r.t e.g. \code{prob[1]} makes sense.
  	\item \cd{dmnorm_chol}: for this, and other distributions which take Cholesky decompositions of covariance matrices as arguments, it seems as though taking derivatives w.r.t. elements of the Cholesky decomposition doesn't make sense.
  	\item \cd{dmvt_chol} and \cd{dwish_chol}:  Neither of these are currently functional 