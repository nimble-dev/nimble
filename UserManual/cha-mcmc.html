<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 7 MCMC | NimbleUserManual.knit</title>
  <meta name="description" content="This is the NIMBLE User Manual." />
  <meta name="generator" content="bookdown 0.36 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 7 MCMC | NimbleUserManual.knit" />
  <meta property="og:type" content="book" />
  <meta property="og:image" content="/nimble-icon.png" />
  <meta property="og:description" content="This is the NIMBLE User Manual." />
  <meta name="github-repo" content="nimble-dev/nimble" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 7 MCMC | NimbleUserManual.knit" />
  
  <meta name="twitter:description" content="This is the NIMBLE User Manual." />
  <meta name="twitter:image" content="/nimble-icon.png" />




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="cha-building-models.html"/>
<link rel="next" href="cha-algos-provided.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<img src="./nimble-icon.png"
     width=100>
<li><a href="./cha-welcome-nimble.html">NIMBLE User Manual, Version 1.2.1</a></li>
<li><a href="https://github.com/nimble-dev/nimble">NIMBLE Development Team</a></li>
<li><a href="https://R-nimble.org">https://R-nimble.org</a></li>

<li class="divider"></li>
<li class="part"><span><b>I Introduction</b></span></li>
<li class="chapter" data-level="1" data-path="cha-welcome-nimble.html"><a href="cha-welcome-nimble.html"><i class="fa fa-check"></i><b>1</b> Welcome to NIMBLE</a>
<ul>
<li class="chapter" data-level="1.1" data-path="cha-welcome-nimble.html"><a href="cha-welcome-nimble.html#sec:what-is-nimble"><i class="fa fa-check"></i><b>1.1</b> What does NIMBLE do?</a></li>
<li class="chapter" data-level="1.2" data-path="cha-welcome-nimble.html"><a href="cha-welcome-nimble.html#how-to-use-this-manual"><i class="fa fa-check"></i><b>1.2</b> How to use this manual</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html"><i class="fa fa-check"></i><b>2</b> Lightning introduction</a>
<ul>
<li class="chapter" data-level="2.1" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:brief-example"><i class="fa fa-check"></i><b>2.1</b> A brief example</a></li>
<li class="chapter" data-level="2.2" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:creating-model"><i class="fa fa-check"></i><b>2.2</b> Creating a model</a></li>
<li class="chapter" data-level="2.3" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:compiling-model"><i class="fa fa-check"></i><b>2.3</b> Compiling the model</a></li>
<li class="chapter" data-level="2.4" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:intro-runMCMC"><i class="fa fa-check"></i><b>2.4</b> One-line invocation of MCMC</a></li>
<li class="chapter" data-level="2.5" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:creating-mcmc"><i class="fa fa-check"></i><b>2.5</b> Creating, compiling and running a basic MCMC configuration</a></li>
<li class="chapter" data-level="2.6" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:customizing-mcmc"><i class="fa fa-check"></i><b>2.6</b> Customizing the MCMC</a></li>
<li class="chapter" data-level="2.7" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:running-mcem"><i class="fa fa-check"></i><b>2.7</b> Running MCEM</a></li>
<li class="chapter" data-level="2.8" data-path="cha-lightning-intro.html"><a href="cha-lightning-intro.html#sec:creating-your-own"><i class="fa fa-check"></i><b>2.8</b> Creating your own functions</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="cha-more-introduction.html"><a href="cha-more-introduction.html"><i class="fa fa-check"></i><b>3</b> More introduction</a>
<ul>
<li class="chapter" data-level="3.1" data-path="cha-more-introduction.html"><a href="cha-more-introduction.html#nimble-adopts-and-extends-the-bugs-language-for-specifying-models"><i class="fa fa-check"></i><b>3.1</b> NIMBLE adopts and extends the BUGS language for specifying models</a></li>
<li class="chapter" data-level="3.2" data-path="cha-more-introduction.html"><a href="cha-more-introduction.html#sec:nimble-lang-writ"><i class="fa fa-check"></i><b>3.2</b> nimbleFunctions for writing algorithms</a></li>
<li class="chapter" data-level="3.3" data-path="cha-more-introduction.html"><a href="cha-more-introduction.html#sec:nimble-algor-libr"><i class="fa fa-check"></i><b>3.3</b> The NIMBLE algorithm library</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html"><i class="fa fa-check"></i><b>4</b> Installing NIMBLE</a>
<ul>
<li class="chapter" data-level="4.1" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#sec:requ-run-nimble"><i class="fa fa-check"></i><b>4.1</b> Requirements to run NIMBLE</a></li>
<li class="chapter" data-level="4.2" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#sec:compiler"><i class="fa fa-check"></i><b>4.2</b> Installing a C++ compiler for NIMBLE to use</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#macos"><i class="fa fa-check"></i><b>4.2.1</b> MacOS</a></li>
<li class="chapter" data-level="4.2.2" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#linux"><i class="fa fa-check"></i><b>4.2.2</b> Linux</a></li>
<li class="chapter" data-level="4.2.3" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#windows"><i class="fa fa-check"></i><b>4.2.3</b> Windows</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#installing-the-nimble-package"><i class="fa fa-check"></i><b>4.3</b> Installing the NIMBLE package</a></li>
<li class="chapter" data-level="4.4" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#troubleshooting-installation-problems"><i class="fa fa-check"></i><b>4.4</b> Troubleshooting installation problems</a></li>
<li class="chapter" data-level="4.5" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#customizing-your-installation"><i class="fa fa-check"></i><b>4.5</b> Customizing your installation</a>
<ul>
<li class="chapter" data-level="4.5.1" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#using-your-own-copy-of-eigen"><i class="fa fa-check"></i><b>4.5.1</b> Using your own copy of Eigen</a></li>
<li class="chapter" data-level="4.5.2" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#using-libnimble"><i class="fa fa-check"></i><b>4.5.2</b> Using libnimble</a></li>
<li class="chapter" data-level="4.5.3" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#sec:blas"><i class="fa fa-check"></i><b>4.5.3</b> BLAS and LAPACK</a></li>
<li class="chapter" data-level="4.5.4" data-path="cha-installing-nimble.html"><a href="cha-installing-nimble.html#customizing-compilation-of-the-nimble-generated-c"><i class="fa fa-check"></i><b>4.5.4</b> Customizing compilation of the NIMBLE-generated C++</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>II Models in NIMBLE</b></span></li>
<li class="chapter" data-level="5" data-path="cha-writing-models.html"><a href="cha-writing-models.html"><i class="fa fa-check"></i><b>5</b> Writing models in NIMBLE’s dialect of BUGS</a>
<ul>
<li class="chapter" data-level="5.1" data-path="cha-writing-models.html"><a href="cha-writing-models.html#sec:supp-feat-bugs"><i class="fa fa-check"></i><b>5.1</b> Comparison to BUGS dialects supported by WinBUGS, OpenBUGS and JAGS</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="cha-writing-models.html"><a href="cha-writing-models.html#supported-features-of-bugs-and-jags"><i class="fa fa-check"></i><b>5.1.1</b> Supported features of BUGS and JAGS</a></li>
<li class="chapter" data-level="5.1.2" data-path="cha-writing-models.html"><a href="cha-writing-models.html#sec:extensions-bugs"><i class="fa fa-check"></i><b>5.1.2</b> NIMBLE’s Extensions to BUGS and JAGS</a></li>
<li class="chapter" data-level="5.1.3" data-path="cha-writing-models.html"><a href="cha-writing-models.html#sec:not-yet-supported"><i class="fa fa-check"></i><b>5.1.3</b> Not-supported features of BUGS and JAGS</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="cha-writing-models.html"><a href="cha-writing-models.html#writing-models"><i class="fa fa-check"></i><b>5.2</b> Writing models</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="cha-writing-models.html"><a href="cha-writing-models.html#declaring-stochastic-and-deterministic-nodes"><i class="fa fa-check"></i><b>5.2.1</b> Declaring stochastic and deterministic nodes</a></li>
<li class="chapter" data-level="5.2.2" data-path="cha-writing-models.html"><a href="cha-writing-models.html#sec:more-kinds-bugs"><i class="fa fa-check"></i><b>5.2.2</b> More kinds of BUGS declarations</a></li>
<li class="chapter" data-level="5.2.3" data-path="cha-writing-models.html"><a href="cha-writing-models.html#subsec:vectorized-versus-scalar-declarations"><i class="fa fa-check"></i><b>5.2.3</b> Vectorized versus scalar declarations</a></li>
<li class="chapter" data-level="5.2.4" data-path="cha-writing-models.html"><a href="cha-writing-models.html#subsec:dists-and-functions"><i class="fa fa-check"></i><b>5.2.4</b> Available distributions</a></li>
<li class="chapter" data-level="5.2.5" data-path="cha-writing-models.html"><a href="cha-writing-models.html#subsec:BUGS-lang-fxns"><i class="fa fa-check"></i><b>5.2.5</b> Available BUGS language functions</a></li>
<li class="chapter" data-level="5.2.6" data-path="cha-writing-models.html"><a href="cha-writing-models.html#subsec:BUGS-link"><i class="fa fa-check"></i><b>5.2.6</b> Available link functions</a></li>
<li class="chapter" data-level="5.2.7" data-path="cha-writing-models.html"><a href="cha-writing-models.html#subsec:trunc"><i class="fa fa-check"></i><b>5.2.7</b> Truncation, censoring, and constraints</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="cha-building-models.html"><a href="cha-building-models.html"><i class="fa fa-check"></i><b>6</b> Building and using models</a>
<ul>
<li class="chapter" data-level="6.1" data-path="cha-building-models.html"><a href="cha-building-models.html#creating-model-objects"><i class="fa fa-check"></i><b>6.1</b> Creating model objects</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="cha-building-models.html"><a href="cha-building-models.html#using-nimblemodel-to-create-a-model"><i class="fa fa-check"></i><b>6.1.1</b> Using <em>nimbleModel</em> to create a model</a></li>
<li class="chapter" data-level="6.1.2" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:readBUGSmodel"><i class="fa fa-check"></i><b>6.1.2</b> Creating a model from standard BUGS and JAGS input files</a></li>
<li class="chapter" data-level="6.1.3" data-path="cha-building-models.html"><a href="cha-building-models.html#sub:multiple-instances"><i class="fa fa-check"></i><b>6.1.3</b> Making multiple instances from the same model definition</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:nodes-and-variables"><i class="fa fa-check"></i><b>6.2</b> NIMBLE models are objects you can query and manipulate</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:what-are-nodes-and-variables"><i class="fa fa-check"></i><b>6.2.1</b> What are variables and nodes?</a></li>
<li class="chapter" data-level="6.2.2" data-path="cha-building-models.html"><a href="cha-building-models.html#determining-the-nodes-and-variables-in-a-model"><i class="fa fa-check"></i><b>6.2.2</b> Determining the nodes and variables in a model</a></li>
<li class="chapter" data-level="6.2.3" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:accessing-nodes"><i class="fa fa-check"></i><b>6.2.3</b> Accessing nodes</a></li>
<li class="chapter" data-level="6.2.4" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:how-nodes-are"><i class="fa fa-check"></i><b>6.2.4</b> How nodes are named</a></li>
<li class="chapter" data-level="6.2.5" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:why-use-node"><i class="fa fa-check"></i><b>6.2.5</b> Why use node names?</a></li>
<li class="chapter" data-level="6.2.6" data-path="cha-building-models.html"><a href="cha-building-models.html#sec:cdisdata"><i class="fa fa-check"></i><b>6.2.6</b> Checking if a node holds data</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="cha-building-models.html"><a href="cha-building-models.html#using-models-in-parallel"><i class="fa fa-check"></i><b>6.3</b> Using models in parallel</a></li>
</ul></li>
<li class="part"><span><b>III Algorithms in NIMBLE</b></span></li>
<li class="chapter" data-level="7" data-path="cha-mcmc.html"><a href="cha-mcmc.html"><i class="fa fa-check"></i><b>7</b> MCMC</a>
<ul>
<li class="chapter" data-level="7.1" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:nimbleMCMC"><i class="fa fa-check"></i><b>7.1</b> One-line invocation of MCMC: <em>nimbleMCMC</em></a></li>
<li class="chapter" data-level="7.2" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:mcmc-configuration"><i class="fa fa-check"></i><b>7.2</b> The MCMC configuration</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:default-mcmc-conf"><i class="fa fa-check"></i><b>7.2.1</b> Default MCMC configuration</a></li>
<li class="chapter" data-level="7.2.2" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:customizing-mcmc-conf"><i class="fa fa-check"></i><b>7.2.2</b> Customizing the MCMC configuration</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:build-compile-mcmc"><i class="fa fa-check"></i><b>7.3</b> Building and compiling the MCMC</a></li>
<li class="chapter" data-level="7.4" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:initMCMC"><i class="fa fa-check"></i><b>7.4</b> Initializing MCMC</a></li>
<li class="chapter" data-level="7.5" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:runMCMC"><i class="fa fa-check"></i><b>7.5</b> User-friendly execution of MCMC algorithms: <em>runMCMC</em></a></li>
<li class="chapter" data-level="7.6" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:executing-the-mcmc-algorithm"><i class="fa fa-check"></i><b>7.6</b> Running the MCMC</a>
<ul>
<li class="chapter" data-level="7.6.1" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:mcmc-rerun"><i class="fa fa-check"></i><b>7.6.1</b> Rerunning versus restarting an MCMC</a></li>
<li class="chapter" data-level="7.6.2" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:sampler-time"><i class="fa fa-check"></i><b>7.6.2</b> Measuring sampler computation times: <em>getTimes</em></a></li>
<li class="chapter" data-level="7.6.3" data-path="cha-mcmc.html"><a href="cha-mcmc.html#assessing-the-adaption-process-of-rw-and-rw_block-samplers"><i class="fa fa-check"></i><b>7.6.3</b> Assessing the adaption process of <em>RW</em> and <em>RW_block</em> samplers</a></li>
</ul></li>
<li class="chapter" data-level="7.7" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:extracting-samples"><i class="fa fa-check"></i><b>7.7</b> Extracting MCMC samples</a></li>
<li class="chapter" data-level="7.8" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:WAIC"><i class="fa fa-check"></i><b>7.8</b> Calculating WAIC</a></li>
<li class="chapter" data-level="7.9" data-path="cha-mcmc.html"><a href="cha-mcmc.html#k-fold-cross-validation"><i class="fa fa-check"></i><b>7.9</b> k-fold cross-validation</a></li>
<li class="chapter" data-level="7.10" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:rjmcmc"><i class="fa fa-check"></i><b>7.10</b> Variable selection using Reversible Jump MCMC</a>
<ul>
<li class="chapter" data-level="7.10.1" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:rjmcmc-indicator"><i class="fa fa-check"></i><b>7.10.1</b> Using indicator variables</a></li>
<li class="chapter" data-level="7.10.2" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:rjmcmc-no-indicator"><i class="fa fa-check"></i><b>7.10.2</b> Without indicator variables</a></li>
</ul></li>
<li class="chapter" data-level="7.11" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:samplers-provided"><i class="fa fa-check"></i><b>7.11</b> Samplers provided with NIMBLE</a>
<ul>
<li class="chapter" data-level="7.11.1" data-path="cha-mcmc.html"><a href="cha-mcmc.html#conjugate-gibbs-samplers"><i class="fa fa-check"></i><b>7.11.1</b> Conjugate (‘Gibbs’) samplers</a></li>
<li class="chapter" data-level="7.11.2" data-path="cha-mcmc.html"><a href="cha-mcmc.html#subsec:HMC"><i class="fa fa-check"></i><b>7.11.2</b> Hamiltonian Monte Carlo (HMC)</a></li>
<li class="chapter" data-level="7.11.3" data-path="cha-mcmc.html"><a href="cha-mcmc.html#particle-filter-samplers"><i class="fa fa-check"></i><b>7.11.3</b> Particle filter samplers</a></li>
<li class="chapter" data-level="7.11.4" data-path="cha-mcmc.html"><a href="cha-mcmc.html#customized-log-likelihood-evaluations-rw_llfunction-sampler"><i class="fa fa-check"></i><b>7.11.4</b> Customized log-likelihood evaluations: <em>RW_llFunction sampler</em></a></li>
</ul></li>
<li class="chapter" data-level="7.12" data-path="cha-mcmc.html"><a href="cha-mcmc.html#sec:mcmc-example-litters"><i class="fa fa-check"></i><b>7.12</b> Detailed MCMC example: <em>litters</em></a></li>
<li class="chapter" data-level="7.13" data-path="cha-mcmc.html"><a href="cha-mcmc.html#mcmc-suite-compare-mcmcs"><i class="fa fa-check"></i><b>7.13</b> Comparing different MCMCs with <em>MCMCsuite</em> and <em>compareMCMCs</em></a></li>
<li class="chapter" data-level="7.14" data-path="cha-mcmc.html"><a href="cha-mcmc.html#running-mcmc-chains-in-parallel"><i class="fa fa-check"></i><b>7.14</b> Running MCMC chains in parallel</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html"><i class="fa fa-check"></i><b>8</b> Particle Filters, PMCMC, MCEM, Laplace approximation and quadrature</a>
<ul>
<li class="chapter" data-level="8.1" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#particle-filters-sequential-monte-carlo-and-iterated-filtering"><i class="fa fa-check"></i><b>8.1</b> Particle filters / sequential Monte Carlo and iterated filtering</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#filtering-algorithms"><i class="fa fa-check"></i><b>8.1.1</b> Filtering algorithms</a></li>
<li class="chapter" data-level="8.1.2" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#sec:particle-mcmc"><i class="fa fa-check"></i><b>8.1.2</b> Particle MCMC (PMCMC)</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#monte-carlo-expectation-maximization-mcem"><i class="fa fa-check"></i><b>8.2</b> Monte Carlo Expectation Maximization (MCEM)</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#sec:estimate-mcem-cov"><i class="fa fa-check"></i><b>8.2.1</b> Estimating the asymptotic covariance From MCEM</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="cha-algos-provided.html"><a href="cha-algos-provided.html#laplace-approximation-and-adaptive-gauss-hermite-quadrature"><i class="fa fa-check"></i><b>8.3</b> Laplace approximation and adaptive Gauss-Hermite quadrature</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="cha-spatial.html"><a href="cha-spatial.html"><i class="fa fa-check"></i><b>9</b> Spatial models</a>
<ul>
<li class="chapter" data-level="9.1" data-path="cha-spatial.html"><a href="cha-spatial.html#intrinsic-gaussian-car-model-dcar_normal"><i class="fa fa-check"></i><b>9.1</b> Intrinsic Gaussian CAR model: <em>dcar_normal</em></a>
<ul>
<li class="chapter" data-level="9.1.1" data-path="cha-spatial.html"><a href="cha-spatial.html#specification-and-density"><i class="fa fa-check"></i><b>9.1.1</b> Specification and density</a></li>
<li class="chapter" data-level="9.1.2" data-path="cha-spatial.html"><a href="cha-spatial.html#example"><i class="fa fa-check"></i><b>9.1.2</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="cha-spatial.html"><a href="cha-spatial.html#proper-gaussian-car-model-dcar_proper"><i class="fa fa-check"></i><b>9.2</b> Proper Gaussian CAR model: <em>dcar_proper</em></a>
<ul>
<li class="chapter" data-level="9.2.1" data-path="cha-spatial.html"><a href="cha-spatial.html#specification-and-density-1"><i class="fa fa-check"></i><b>9.2.1</b> Specification and density</a></li>
<li class="chapter" data-level="9.2.2" data-path="cha-spatial.html"><a href="cha-spatial.html#example-1"><i class="fa fa-check"></i><b>9.2.2</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="cha-spatial.html"><a href="cha-spatial.html#sec:spatial-mcmc-sampling-car"><i class="fa fa-check"></i><b>9.3</b> MCMC Sampling of CAR models</a>
<ul>
<li class="chapter" data-level="9.3.1" data-path="cha-spatial.html"><a href="cha-spatial.html#initial-values"><i class="fa fa-check"></i><b>9.3.1</b> Initial values</a></li>
<li class="chapter" data-level="9.3.2" data-path="cha-spatial.html"><a href="cha-spatial.html#zero-neighbor-regions"><i class="fa fa-check"></i><b>9.3.2</b> Zero-neighbor regions</a></li>
<li class="chapter" data-level="9.3.3" data-path="cha-spatial.html"><a href="cha-spatial.html#zero-mean-constraint"><i class="fa fa-check"></i><b>9.3.3</b> Zero-mean constraint</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="cha-bnp.html"><a href="cha-bnp.html"><i class="fa fa-check"></i><b>10</b> Bayesian nonparametric models</a>
<ul>
<li class="chapter" data-level="10.1" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:bnpmixtures"><i class="fa fa-check"></i><b>10.1</b> Bayesian nonparametric mixture models</a></li>
<li class="chapter" data-level="10.2" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:crp"><i class="fa fa-check"></i><b>10.2</b> Chinese Restaurant Process model</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="cha-bnp.html"><a href="cha-bnp.html#specification-and-density-2"><i class="fa fa-check"></i><b>10.2.1</b> Specification and density</a></li>
<li class="chapter" data-level="10.2.2" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:excrp"><i class="fa fa-check"></i><b>10.2.2</b> Example</a></li>
<li class="chapter" data-level="10.2.3" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:extensionscrp"><i class="fa fa-check"></i><b>10.2.3</b> Extensions</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:sb"><i class="fa fa-check"></i><b>10.3</b> Stick-breaking model</a>
<ul>
<li class="chapter" data-level="10.3.1" data-path="cha-bnp.html"><a href="cha-bnp.html#specification-and-function"><i class="fa fa-check"></i><b>10.3.1</b> Specification and function</a></li>
<li class="chapter" data-level="10.3.2" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:exsb"><i class="fa fa-check"></i><b>10.3.2</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="cha-bnp.html"><a href="cha-bnp.html#mcmc-sampling-of-bnp-models"><i class="fa fa-check"></i><b>10.4</b> MCMC sampling of BNP models</a>
<ul>
<li class="chapter" data-level="10.4.1" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:mcmcdcrp"><i class="fa fa-check"></i><b>10.4.1</b> Sampling CRP models</a></li>
<li class="chapter" data-level="10.4.2" data-path="cha-bnp.html"><a href="cha-bnp.html#sec:mcmcsb"><i class="fa fa-check"></i><b>10.4.2</b> Sampling stick-breaking models</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV Programming with NIMBLE</b></span></li>
<li class="chapter" data-level="" data-path="overview.html"><a href="overview.html"><i class="fa fa-check"></i>Overview</a></li>
<li class="chapter" data-level="11" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html"><i class="fa fa-check"></i><b>11</b> Writing simple nimbleFunctions</a>
<ul>
<li class="chapter" data-level="11.1" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:RC-intro"><i class="fa fa-check"></i><b>11.1</b> Introduction to simple nimbleFunctions</a></li>
<li class="chapter" data-level="11.2" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:r-fiunctions-implemented"><i class="fa fa-check"></i><b>11.2</b> R functions (or variants) implemented in NIMBLE</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#finding-help-for-nimbles-versions-of-r-functions"><i class="fa fa-check"></i><b>11.2.1</b> Finding help for NIMBLE’s versions of R functions</a></li>
<li class="chapter" data-level="11.2.2" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#basic-operations"><i class="fa fa-check"></i><b>11.2.2</b> Basic operations</a></li>
<li class="chapter" data-level="11.2.3" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:basic-math-linear"><i class="fa fa-check"></i><b>11.2.3</b> Math and linear algebra</a></li>
<li class="chapter" data-level="11.2.4" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:nimble-dist-funs"><i class="fa fa-check"></i><b>11.2.4</b> Distribution functions</a></li>
<li class="chapter" data-level="11.2.5" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:basic-flow-control"><i class="fa fa-check"></i><b>11.2.5</b> Flow control: <em>if-then-else</em>, <em>for</em>, <em>while</em>, and <em>stop</em></a></li>
<li class="chapter" data-level="11.2.6" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:print"><i class="fa fa-check"></i><b>11.2.6</b> <em>print</em> and <em>cat</em></a></li>
<li class="chapter" data-level="11.2.7" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:check-user-interr"><i class="fa fa-check"></i><b>11.2.7</b> Checking for user interrupts: <em>checkInterrupt</em></a></li>
<li class="chapter" data-level="11.2.8" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#optimization-optim-and-nimoptim"><i class="fa fa-check"></i><b>11.2.8</b> Optimization: <em>optim</em> and <em>nimOptim</em></a></li>
<li class="chapter" data-level="11.2.9" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#integration-integrate-and-nimintegrate"><i class="fa fa-check"></i><b>11.2.9</b> Integration: <em>integrate</em> and <em>nimIntegrate</em></a></li>
<li class="chapter" data-level="11.2.10" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:altern-keyw-some"><i class="fa fa-check"></i><b>11.2.10</b> ‘nim’ synonyms for some functions</a></li>
</ul></li>
<li class="chapter" data-level="11.3" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:how-nimble-handles"><i class="fa fa-check"></i><b>11.3</b> How NIMBLE handles types of variables</a>
<ul>
<li class="chapter" data-level="11.3.1" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:nimbleList-RCFuns"><i class="fa fa-check"></i><b>11.3.1</b> nimbleList data structures</a></li>
<li class="chapter" data-level="11.3.2" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:how-types-work"><i class="fa fa-check"></i><b>11.3.2</b> How numeric types work</a></li>
</ul></li>
<li class="chapter" data-level="11.4" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:decl-argum-return"><i class="fa fa-check"></i><b>11.4</b> Declaring argument and return types</a></li>
<li class="chapter" data-level="11.5" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:comp-nimbl-pass"><i class="fa fa-check"></i><b>11.5</b> Compiled nimbleFunctions pass arguments by reference</a></li>
<li class="chapter" data-level="11.6" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:calling-external-code"><i class="fa fa-check"></i><b>11.6</b> Calling external compiled code</a></li>
<li class="chapter" data-level="11.7" data-path="cha-RCfunctions.html"><a href="cha-RCfunctions.html#sec:calling-R-code"><i class="fa fa-check"></i><b>11.7</b> Calling uncompiled R functions from compiled nimbleFunctions</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="cha-user-defined.html"><a href="cha-user-defined.html"><i class="fa fa-check"></i><b>12</b> Creating user-defined distributions and functions for models</a>
<ul>
<li class="chapter" data-level="12.1" data-path="cha-user-defined.html"><a href="cha-user-defined.html#sec:user-functions"><i class="fa fa-check"></i><b>12.1</b> User-defined functions</a></li>
<li class="chapter" data-level="12.2" data-path="cha-user-defined.html"><a href="cha-user-defined.html#sec:user-distributions"><i class="fa fa-check"></i><b>12.2</b> User-defined distributions</a>
<ul>
<li class="chapter" data-level="12.2.1" data-path="cha-user-defined.html"><a href="cha-user-defined.html#sec:registerDistributions"><i class="fa fa-check"></i><b>12.2.1</b> Using <em>registerDistributions</em> for alternative parameterizations and providing other information</a></li>
</ul></li>
<li class="chapter" data-level="12.3" data-path="cha-user-defined.html"><a href="cha-user-defined.html#sec:adv-user-def"><i class="fa fa-check"></i><b>12.3</b> Advanced user-defined functions and distributions</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="cha-using-models.html"><a href="cha-using-models.html"><i class="fa fa-check"></i><b>13</b> Working with NIMBLE models</a>
<ul>
<li class="chapter" data-level="13.1" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:accessing-variables"><i class="fa fa-check"></i><b>13.1</b> The variables and nodes in a NIMBLE model</a>
<ul>
<li class="chapter" data-level="13.1.1" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:get-nodes"><i class="fa fa-check"></i><b>13.1.1</b> Determining the nodes in a model</a></li>
<li class="chapter" data-level="13.1.2" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:introduced-nodes"><i class="fa fa-check"></i><b>13.1.2</b> Understanding lifted nodes</a></li>
<li class="chapter" data-level="13.1.3" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:cdgetdependencies"><i class="fa fa-check"></i><b>13.1.3</b> Determining dependencies in a model</a></li>
</ul></li>
<li class="chapter" data-level="13.2" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:nodeInfo"><i class="fa fa-check"></i><b>13.2</b> Accessing information about nodes and variables</a>
<ul>
<li class="chapter" data-level="13.2.1" data-path="cha-using-models.html"><a href="cha-using-models.html#getting-distributional-information-about-a-node"><i class="fa fa-check"></i><b>13.2.1</b> Getting distributional information about a node</a></li>
<li class="chapter" data-level="13.2.2" data-path="cha-using-models.html"><a href="cha-using-models.html#getting-information-about-a-distribution"><i class="fa fa-check"></i><b>13.2.2</b> Getting information about a distribution</a></li>
<li class="chapter" data-level="13.2.3" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:getParam"><i class="fa fa-check"></i><b>13.2.3</b> Getting distribution parameter values for a node</a></li>
<li class="chapter" data-level="13.2.4" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:getBound"><i class="fa fa-check"></i><b>13.2.4</b> Getting distribution bounds for a node</a></li>
</ul></li>
<li class="chapter" data-level="13.3" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:cdcalc-cdsim-cdgetl"><i class="fa fa-check"></i><b>13.3</b> Carrying out model calculations</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="cha-using-models.html"><a href="cha-using-models.html#core-model-operations-calculation-and-simulation"><i class="fa fa-check"></i><b>13.3.1</b> Core model operations: calculation and simulation</a></li>
<li class="chapter" data-level="13.3.2" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:cdsimn-cdcalcn-cdget"><i class="fa fa-check"></i><b>13.3.2</b> Pre-defined nimbleFunctions for operating on model nodes: <em>simNodes</em>, <em>calcNodes</em>, and <em>getLogProbNodes</em></a></li>
<li class="chapter" data-level="13.3.3" data-path="cha-using-models.html"><a href="cha-using-models.html#sec:access-log-prob"><i class="fa fa-check"></i><b>13.3.3</b> Accessing log probabilities via <em>logProb</em> variables</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="14" data-path="cha-data-structures.html"><a href="cha-data-structures.html"><i class="fa fa-check"></i><b>14</b> Data structures in NIMBLE</a>
<ul>
<li class="chapter" data-level="14.1" data-path="cha-data-structures.html"><a href="cha-data-structures.html#sec:modelValues-struct"><i class="fa fa-check"></i><b>14.1</b> The modelValues data structure</a>
<ul>
<li class="chapter" data-level="14.1.1" data-path="cha-data-structures.html"><a href="cha-data-structures.html#creating-modelvalues-objects"><i class="fa fa-check"></i><b>14.1.1</b> Creating modelValues objects</a></li>
<li class="chapter" data-level="14.1.2" data-path="cha-data-structures.html"><a href="cha-data-structures.html#sec:access-cont-modelv"><i class="fa fa-check"></i><b>14.1.2</b> Accessing contents of modelValues</a></li>
</ul></li>
<li class="chapter" data-level="14.2" data-path="cha-data-structures.html"><a href="cha-data-structures.html#sec:nimbleLists"><i class="fa fa-check"></i><b>14.2</b> The nimbleList data structure</a>
<ul>
<li class="chapter" data-level="14.2.1" data-path="cha-data-structures.html"><a href="cha-data-structures.html#sec:predef-nimbleLists"><i class="fa fa-check"></i><b>14.2.1</b> Pre-defined nimbleList types</a></li>
<li class="chapter" data-level="14.2.2" data-path="cha-data-structures.html"><a href="cha-data-structures.html#sec:eigen-nimFunctions"><i class="fa fa-check"></i><b>14.2.2</b> Using <em>eigen</em> and <em>svd</em> in nimbleFunctions</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html"><i class="fa fa-check"></i><b>15</b> Writing nimbleFunctions to interact with models</a>
<ul>
<li class="chapter" data-level="15.1" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:writ-nimble-funct"><i class="fa fa-check"></i><b>15.1</b> Overview</a></li>
<li class="chapter" data-level="15.2" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:using-comp-nimbl"><i class="fa fa-check"></i><b>15.2</b> Using and compiling nimbleFunctions</a></li>
<li class="chapter" data-level="15.3" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#writing-setup-code"><i class="fa fa-check"></i><b>15.3</b> Writing setup code</a>
<ul>
<li class="chapter" data-level="15.3.1" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#useful-tools-for-setup-functions"><i class="fa fa-check"></i><b>15.3.1</b> Useful tools for setup functions</a></li>
<li class="chapter" data-level="15.3.2" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:access-modify-numer"><i class="fa fa-check"></i><b>15.3.2</b> Accessing and modifying numeric values from setup</a></li>
<li class="chapter" data-level="15.3.3" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#determining-numeric-types-in-nimblefunctions"><i class="fa fa-check"></i><b>15.3.3</b> Determining numeric types in nimbleFunctions</a></li>
<li class="chapter" data-level="15.3.4" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:determ-pers-texttts"><i class="fa fa-check"></i><b>15.3.4</b> Control of setup outputs</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:nimble-lang-comp"><i class="fa fa-check"></i><b>15.4</b> Writing run code</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:driv-models:-calc"><i class="fa fa-check"></i><b>15.4.1</b> Driving models: <em>calculate</em>, <em>calculateDiff</em>, <em>simulate</em>, <em>getLogProb</em></a></li>
<li class="chapter" data-level="15.4.2" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#getting-and-setting-variable-and-node-values"><i class="fa fa-check"></i><b>15.4.2</b> Getting and setting variable and node values</a></li>
<li class="chapter" data-level="15.4.3" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#getting-parameter-values-and-node-bounds"><i class="fa fa-check"></i><b>15.4.3</b> Getting parameter values and node bounds</a></li>
<li class="chapter" data-level="15.4.4" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:access-model-modelv"><i class="fa fa-check"></i><b>15.4.4</b> Using modelValues objects</a></li>
<li class="chapter" data-level="15.4.5" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:using-model-variable"><i class="fa fa-check"></i><b>15.4.5</b> Using model variables and modelValues in expressions</a></li>
<li class="chapter" data-level="15.4.6" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:incl-other-meth"><i class="fa fa-check"></i><b>15.4.6</b> Including other methods in a nimbleFunction</a></li>
<li class="chapter" data-level="15.4.7" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:using-other-nimbl"><i class="fa fa-check"></i><b>15.4.7</b> Using other nimbleFunctions</a></li>
<li class="chapter" data-level="15.4.8" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:virt-nimbl-nimbl"><i class="fa fa-check"></i><b>15.4.8</b> Virtual nimbleFunctions and nimbleFunctionLists</a></li>
<li class="chapter" data-level="15.4.9" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#character-objects"><i class="fa fa-check"></i><b>15.4.9</b> Character objects</a></li>
<li class="chapter" data-level="15.4.10" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:user-defined-data"><i class="fa fa-check"></i><b>15.4.10</b> User-defined data structures</a></li>
</ul></li>
<li class="chapter" data-level="15.5" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:user-samplers"><i class="fa fa-check"></i><b>15.5</b> Example: writing user-defined samplers to extend NIMBLE’s MCMC engine</a>
<ul>
<li class="chapter" data-level="15.5.1" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#user-defined-samplers-and-posterior-predictive-nodes"><i class="fa fa-check"></i><b>15.5.1</b> User-defined samplers and posterior predictive nodes</a></li>
</ul></li>
<li class="chapter" data-level="15.6" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#copying-nimblefunctions-and-nimble-models"><i class="fa fa-check"></i><b>15.6</b> Copying nimbleFunctions (and NIMBLE models)</a></li>
<li class="chapter" data-level="15.7" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#sec:debugging"><i class="fa fa-check"></i><b>15.7</b> Debugging nimbleFunctions</a></li>
<li class="chapter" data-level="15.8" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#timing-nimblefunctions-with-run.time"><i class="fa fa-check"></i><b>15.8</b> Timing nimbleFunctions with <em>run.time</em></a></li>
<li class="chapter" data-level="15.9" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#clearing-and-unloading-compiled-objects"><i class="fa fa-check"></i><b>15.9</b> Clearing and unloading compiled objects</a></li>
<li class="chapter" data-level="15.10" data-path="cha-progr-with-models.html"><a href="cha-progr-with-models.html#reducing-memory-usage"><i class="fa fa-check"></i><b>15.10</b> Reducing memory usage</a></li>
</ul></li>
<li class="part"><span><b>V Automatic Derivatives in NIMBLE</b></span></li>
<li class="chapter" data-level="16" data-path="cha-AD.html"><a href="cha-AD.html"><i class="fa fa-check"></i><b>16</b> Automatic Derivatives</a>
<ul>
<li class="chapter" data-level="16.1" data-path="cha-AD.html"><a href="cha-AD.html#sec:use-derivs"><i class="fa fa-check"></i><b>16.1</b> How to turn on derivatives in a model</a>
<ul>
<li class="chapter" data-level="16.1.1" data-path="cha-AD.html"><a href="cha-AD.html#finish-setting-up-the-glmm-example"><i class="fa fa-check"></i><b>16.1.1</b> Finish setting up the GLMM example</a></li>
</ul></li>
<li class="chapter" data-level="16.2" data-path="cha-AD.html"><a href="cha-AD.html#sec:AD-laplace"><i class="fa fa-check"></i><b>16.2</b> How to use Laplace approximation and adaptive Gauss-Hermite quadrature</a></li>
<li class="chapter" data-level="16.3" data-path="cha-AD.html"><a href="cha-AD.html#sec:AD-user-def"><i class="fa fa-check"></i><b>16.3</b> How to support derivatives in user-defined functions and distributions</a></li>
<li class="chapter" data-level="16.4" data-path="cha-AD.html"><a href="cha-AD.html#what-operations-are-and-arent-supported-for-ad"><i class="fa fa-check"></i><b>16.4</b> What operations are and aren’t supported for AD</a></li>
<li class="chapter" data-level="16.5" data-path="cha-AD.html"><a href="cha-AD.html#basics-of-obtaining-derivatives-in-nimblefunctions"><i class="fa fa-check"></i><b>16.5</b> Basics of obtaining derivatives in <code>nimbleFunctions</code></a>
<ul>
<li class="chapter" data-level="16.5.1" data-path="cha-AD.html"><a href="cha-AD.html#checking-derivatives-with-uncompiled-execution"><i class="fa fa-check"></i><b>16.5.1</b> Checking derivatives with uncompiled execution</a></li>
<li class="chapter" data-level="16.5.2" data-path="cha-AD.html"><a href="cha-AD.html#sec:AD-holding-out"><i class="fa fa-check"></i><b>16.5.2</b> Holding some local variables out of derivative tracking</a></li>
<li class="chapter" data-level="16.5.3" data-path="cha-AD.html"><a href="cha-AD.html#sec:AD-multiple-NF"><i class="fa fa-check"></i><b>16.5.3</b> Using AD with multiple nimbleFunctions</a></li>
<li class="chapter" data-level="16.5.4" data-path="cha-AD.html"><a href="cha-AD.html#sec:understanding-more-AD"><i class="fa fa-check"></i><b>16.5.4</b> Understanding more about how AD works: <em>taping</em> of operations</a></li>
<li class="chapter" data-level="16.5.5" data-path="cha-AD.html"><a href="cha-AD.html#resetting-a-nimderivs-call"><i class="fa fa-check"></i><b>16.5.5</b> Resetting a <code>nimDerivs</code> call</a></li>
<li class="chapter" data-level="16.5.6" data-path="cha-AD.html"><a href="cha-AD.html#a-note-on-performance-benchmarking"><i class="fa fa-check"></i><b>16.5.6</b> A note on performance benchmarking</a></li>
</ul></li>
<li class="chapter" data-level="16.6" data-path="cha-AD.html"><a href="cha-AD.html#advanced-uses-double-taping"><i class="fa fa-check"></i><b>16.6</b> Advanced uses: double taping</a></li>
<li class="chapter" data-level="16.7" data-path="cha-AD.html"><a href="cha-AD.html#derivatives-involving-model-calculations"><i class="fa fa-check"></i><b>16.7</b> Derivatives involving model calculations</a>
<ul>
<li class="chapter" data-level="16.7.1" data-path="cha-AD.html"><a href="cha-AD.html#method-1-nimderivs-of-modelcalculate"><i class="fa fa-check"></i><b>16.7.1</b> Method 1: <code>nimDerivs</code> of <code>model$calculate</code></a></li>
<li class="chapter" data-level="16.7.2" data-path="cha-AD.html"><a href="cha-AD.html#method-2-nimderivs-of-a-method-that-calls-modelcalculate"><i class="fa fa-check"></i><b>16.7.2</b> Method 2: <code>nimDerivs</code> of a method that calls <code>model$calculate</code></a></li>
</ul></li>
<li class="chapter" data-level="16.8" data-path="cha-AD.html"><a href="cha-AD.html#sec:parameter-transform"><i class="fa fa-check"></i><b>16.8</b> Parameter transformations</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="example-maximum-likelihood-estimation-using-optim-with-gradients-from-nimderivs..html"><a href="example-maximum-likelihood-estimation-using-optim-with-gradients-from-nimderivs..html"><i class="fa fa-check"></i><b>17</b> Example: maximum likelihood estimation using <code>optim</code> with gradients from <code>nimDerivs</code>.</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="cha-mcmc" class="section level1 hasAnchor" number="7">
<h1><span class="header-section-number">Chapter 7</span> MCMC<a href="cha-mcmc.html#cha-mcmc" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>NIMBLE provides a variety of paths to creating and executing an MCMC algorithm, which differ greatly in their simplicity of use, and also in the options available and customizability.</p>
<p>The most direct approach to invoking the MCMC engine is using the <code>nimbleMCMC</code> function (Section <a href="cha-mcmc.html#sec:nimbleMCMC">7.1</a>). This one-line call creates and executes an MCMC, and provides a wide range of options for controlling the MCMC: specifying monitors, burn-in, and thinning, running multiple MCMC chains with different initial values, and returning posterior samples, summary statistics, and/or a WAIC value. However, this approach is restricted to using NIMBLE’s default MCMC algorithm; further customization of, for example, the specific samplers employed, is not possible.</p>
<p>The lengthier and more customizable approach to invoking the MCMC engine on a particular NIMBLE model object involves the following steps:</p>
<ol style="list-style-type: decimal">
<li><p>(Optional) Create and customize an MCMC configuration for a particular model:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Use <code>configureMCMC</code> to create an MCMC configuration (see Section <a href="cha-mcmc.html#sec:mcmc-configuration">7.2</a>). The configuration contains a list of samplers with the node(s) they will sample.</p></li>
<li><p>(Optional) Customize the MCMC configuration:</p>
<ol style="list-style-type: lower-roman">
<li>Add, remove, or re-order the list of samplers (Section <a href="cha-mcmc.html#sec:samplers-provided">7.11</a> and <code>help(samplers)</code> in R for details), including adding your own samplers (Section <a href="cha-progr-with-models.html#sec:user-samplers">15.5</a>);</li>
<li>Change the tuning parameters or adaptive properties of individual samplers;</li>
<li>Change the variables to monitor (record for output) and thinning intervals for MCMC samples.</li>
</ol></li>
</ol></li>
<li><p>Use <code>buildMCMC</code> to build the MCMC object and its samplers either from the model (using default MCMC configuration) or from a customized MCMC configuration (Section <a href="cha-mcmc.html#sec:build-compile-mcmc">7.3</a>).</p></li>
<li><p>Compile the MCMC object (and the model), unless one is debugging and wishes to run the uncompiled MCMC.</p></li>
<li><p>Run the MCMC and extract the samples (Sections <a href="cha-mcmc.html#sec:runMCMC">7.5</a>, <a href="cha-mcmc.html#sec:executing-the-mcmc-algorithm">7.6</a> and <a href="cha-mcmc.html#sec:extracting-samples">7.7</a>).</p></li>
<li><p>Optionally, calculate the WAIC (Section <a href="cha-mcmc.html#sec:WAIC">7.8</a>).</p></li>
</ol>
<p>Prior to version 0.8.0, NIMBLE provided two additional functions, <code>MCMCsuite</code> and <code>compareMCMCs</code>, to facilitate comparison of multiple MCMC algorithms, either internal or external to NIMBLE. Those capabilities have been redesigned and moved into a separate package called <code>compareMCMCs</code>.</p>
<p>End-to-end examples of MCMC in NIMBLE can be found in Sections <a href="cha-lightning-intro.html#sec:creating-mcmc">2.5</a>-<a href="cha-lightning-intro.html#sec:customizing-mcmc">2.6</a> and Section <a href="cha-mcmc.html#sec:mcmc-example-litters">7.12</a>.
<!---  ### Creating an MCMC algorithm --></p>
<!---  A default MCMC algorithm can be created using `buildMCMC(model)`.  See Section \@ref(sec:build-compile-mcmc). -->
<!---  To customize properties of the MCMC algorithm -- including the sampling algorithms, joint (block) sampling of dimensions, tuning and adaptive properties of sampling algorithms, variables being monitored (posterior samples are collected), and the thinning interval for sample collection -- an MCMC configuration object (`conf`) must be created using `configureMCMC(model)`.  Properties of the MCMC algorithm can be modified using the `conf` object, after which an MCMC algorithm (`mcmc`) can be created using `buildMCMC(conf)`.  See Section \@ref(mcmc-configuration). -->
<!---  Both the `model` and `mcmc` should generally be compiled using `compileNimble`, for significantly faster execution (Section \@ref(sec:build-compile-mcmc)).  We'll refer to the compiled MCMC algorithm as `Cmcmc`. -->
<!---  ### Executing an MCMC algorithm and collecting samples -->
<!---  There are two methods available to execute an MCMC algorithm: -->
<!---   
%   1. `Cmcmc$run(...)`
%    1. `runMCMC(Cmcmc, ...)` -->
<!---  Using `Cmcmc$run(...)` provides lower-level options including extending an MCMC run (collecting additional samples from where it last stopped), and also collecting timing information for the internal sampling algorithms.  After executing an MCMC in this manner, posterior samples are extracted from within the `Cmcmc` object using `as.matrix(Cmcmc$mvSamples)`.  See Sections \@ref(sec:executing-the-mcmc-algorithm) and \@ref(sec:extracting-samples). -->
<!---  Using `runMCMC(Cmcmc, ...)` provides higher-level options such as running multiple chains, setting initial values, removing burn-in, and returning posterior samples in the form of a `coda` `mcmc` object.  Running an MCMC in this manner returns an array of samples, a list of sample arrays in the case of multiple chains, or optionally a `coda` object.  See Section \@ref(sec:runMCMC). -->
<!---  ### Other topics -->
<!---  In addition to details of the steps outlined above, this chapter also includes: -->
<!---   
% %%  1. NIMBLE's algorithm to search blocks of nodes for efficient joint (block) sampling (section \@ref(sec:default-mcmc-conf)) -->
<!---    1. Information about the sampling algorithms provided with NIMBLE (Section \@ref(sec:samplers-provided)) 
%   1. A detailed example of using the MCMC engine (section \@ref(sec:mcmc-example-litters)) -->
<!---    1. Methods to automatically run WinBUGS, OpenBUGS, JAGS, Stan and/or multiple NIMBLE MCMCs on the same model (section \@ref(mcmc-suite-compare-mcmcs))  -->
<div id="sec:nimbleMCMC" class="section level2 hasAnchor" number="7.1">
<h2><span class="header-section-number">7.1</span> One-line invocation of MCMC: <em>nimbleMCMC</em><a href="cha-mcmc.html#sec:nimbleMCMC" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The most direct approach to executing an MCMC algorithm in NIMBLE is using <code>nimbleMCMC</code>. This single function can be used to create an underlying model and associated MCMC algorithm, compile both of these, execute the MCMC, and return samples, summary statistics, and a WAIC value. This approach circumvents the longer (and more flexible) approach using <code>nimbleModel</code>, <code>configureMCMC</code>, <code>buildMCMC</code>, <code>compileNimble</code>, and <code>runMCMC</code>, which is described subsequently.</p>
<p>The <code>nimbleMCMC</code> function provides control over the:</p>
<ul>
<li>number of MCMC iterations in each chain;</li>
<li>number of MCMC chains to execute;</li>
<li>number of burn-in samples to discard from each chain;</li>
<li>thinning interval on which samples should be recorded;</li>
<li>model variables to monitor and return posterior samples;</li>
<li>initial values, or a function for generating initial values for each chain;</li>
<li>setting the random number seed;</li>
<li>returning posterior samples as a matrix or a <code>coda</code> <code>mcmc</code> object;</li>
<li>returning posterior summary statistics; and</li>
<li>returning a WAIC value calculated using post-burn-in samples from all chains.</li>
</ul>
<p>This entry point for using <code>nimbleMCMC</code> is the <code>code</code>, <code>constants</code>, <code>data</code>, and <code>inits</code> arguments that are used for building a NIMBLE model (see Chapters <a href="cha-writing-models.html#cha-writing-models">5</a> and <a href="cha-building-models.html#cha-building-models">6</a>). However, when using <code>nimbleMCMC</code>, the <code>inits</code> argument can also specify a list of lists of initial values that will be used for each MCMC chain, or a function that generates a list of initial values, which will be generated at the onset of each chain. As an alternative entry point, a NIMBLE <code>model</code> object can also be supplied to <code>nimbleMCMC</code>, in which case this model will be used to build the MCMC algorithm.</p>
<p>Based on its arguments, <code>nimbleMCMC</code> optionally returns any combination of</p>
<ul>
<li>Posterior samples,</li>
<li>Posterior summary statistics, and</li>
<li>WAIC value.</li>
</ul>
<p>The above are calculated and returned for each MCMC chain, using the post-burn-in and thinned samples. Additionally, posterior summary statistics are calculated for all chains combined when multiple chains are run.</p>
<p>Several example usages of <code>nimbleMCMC</code> are shown below:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb143-1"><a href="cha-mcmc.html#cb143-1" tabindex="-1"></a>code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb143-2"><a href="cha-mcmc.html#cb143-2" tabindex="-1"></a>    mu <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1000</span>)</span>
<span id="cb143-3"><a href="cha-mcmc.html#cb143-3" tabindex="-1"></a>    sigma <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>, <span class="dv">1000</span>)</span>
<span id="cb143-4"><a href="cha-mcmc.html#cb143-4" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)</span>
<span id="cb143-5"><a href="cha-mcmc.html#cb143-5" tabindex="-1"></a>        x[i] <span class="sc">~</span> <span class="fu">dnorm</span>(mu, <span class="at">sd =</span> sigma)</span>
<span id="cb143-6"><a href="cha-mcmc.html#cb143-6" tabindex="-1"></a>})</span>
<span id="cb143-7"><a href="cha-mcmc.html#cb143-7" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">3</span>))</span>
<span id="cb143-8"><a href="cha-mcmc.html#cb143-8" tabindex="-1"></a>initsFunction <span class="ot">&lt;-</span> <span class="cf">function</span>() <span class="fu">list</span>(<span class="at">mu =</span> <span class="fu">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">sigma =</span> <span class="fu">runif</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">10</span>))</span>
<span id="cb143-9"><a href="cha-mcmc.html#cb143-9" tabindex="-1"></a></span>
<span id="cb143-10"><a href="cha-mcmc.html#cb143-10" tabindex="-1"></a><span class="co"># execute one MCMC chain, monitoring the &quot;mu&quot; and &quot;sigma&quot; variables,</span></span>
<span id="cb143-11"><a href="cha-mcmc.html#cb143-11" tabindex="-1"></a><span class="co"># with thinning interval 10.  fix the random number seed for reproducible</span></span>
<span id="cb143-12"><a href="cha-mcmc.html#cb143-12" tabindex="-1"></a><span class="co"># results.  by default, only returns posterior samples.</span></span>
<span id="cb143-13"><a href="cha-mcmc.html#cb143-13" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">nimbleMCMC</span>(<span class="at">code =</span> code, <span class="at">data =</span> data, <span class="at">inits =</span> initsFunction,</span>
<span id="cb143-14"><a href="cha-mcmc.html#cb143-14" tabindex="-1"></a>                       <span class="at">monitors =</span> <span class="fu">c</span>(<span class="st">&quot;mu&quot;</span>, <span class="st">&quot;sigma&quot;</span>), <span class="at">thin =</span> <span class="dv">10</span>,</span>
<span id="cb143-15"><a href="cha-mcmc.html#cb143-15" tabindex="-1"></a>                       <span class="at">niter =</span> <span class="dv">20000</span>, <span class="at">nchains =</span> <span class="dv">1</span>, <span class="at">setSeed =</span> <span class="cn">TRUE</span>)</span>
<span id="cb143-16"><a href="cha-mcmc.html#cb143-16" tabindex="-1"></a></span>
<span id="cb143-17"><a href="cha-mcmc.html#cb143-17" tabindex="-1"></a><span class="co"># note that the inits argument to nimbleModel must be a list of</span></span>
<span id="cb143-18"><a href="cha-mcmc.html#cb143-18" tabindex="-1"></a><span class="co"># initial values, whereas nimbleMCMC can accept inits as a function</span></span>
<span id="cb143-19"><a href="cha-mcmc.html#cb143-19" tabindex="-1"></a><span class="co"># for generating new initial values for each chain.</span></span>
<span id="cb143-20"><a href="cha-mcmc.html#cb143-20" tabindex="-1"></a>initsList <span class="ot">&lt;-</span> <span class="fu">initsFunction</span>()</span>
<span id="cb143-21"><a href="cha-mcmc.html#cb143-21" tabindex="-1"></a>Rmodel <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(code, <span class="at">data =</span> data, <span class="at">inits =</span> initsList)</span>
<span id="cb143-22"><a href="cha-mcmc.html#cb143-22" tabindex="-1"></a></span>
<span id="cb143-23"><a href="cha-mcmc.html#cb143-23" tabindex="-1"></a><span class="co"># using the existing Rmodel object, execute three MCMC chains with </span></span>
<span id="cb143-24"><a href="cha-mcmc.html#cb143-24" tabindex="-1"></a><span class="co"># specified burn-in.  return samples, summary statistics, and WAIC.</span></span>
<span id="cb143-25"><a href="cha-mcmc.html#cb143-25" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">nimbleMCMC</span>(<span class="at">model =</span> Rmodel,</span>
<span id="cb143-26"><a href="cha-mcmc.html#cb143-26" tabindex="-1"></a>                       <span class="at">niter =</span> <span class="dv">20000</span>, <span class="at">nchains =</span> <span class="dv">3</span>, <span class="at">nburnin =</span> <span class="dv">2000</span>,</span>
<span id="cb143-27"><a href="cha-mcmc.html#cb143-27" tabindex="-1"></a>                       <span class="at">summary =</span> <span class="cn">TRUE</span>, <span class="at">WAIC =</span> <span class="cn">TRUE</span>)</span>
<span id="cb143-28"><a href="cha-mcmc.html#cb143-28" tabindex="-1"></a></span>
<span id="cb143-29"><a href="cha-mcmc.html#cb143-29" tabindex="-1"></a><span class="co"># run ten chains, generating random initial values for each</span></span>
<span id="cb143-30"><a href="cha-mcmc.html#cb143-30" tabindex="-1"></a><span class="co"># chain using the inits function specified above.</span></span>
<span id="cb143-31"><a href="cha-mcmc.html#cb143-31" tabindex="-1"></a><span class="co"># only return summary statistics from each chain; not all the samples.</span></span>
<span id="cb143-32"><a href="cha-mcmc.html#cb143-32" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">nimbleMCMC</span>(<span class="at">model =</span> Rmodel, <span class="at">nchains =</span> <span class="dv">10</span>, <span class="at">inits =</span> initsFunction,</span>
<span id="cb143-33"><a href="cha-mcmc.html#cb143-33" tabindex="-1"></a>                       <span class="at">samples =</span> <span class="cn">FALSE</span>, <span class="at">summary =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>See <code>help(nimbleMCMC)</code> for further details.</p>
</div>
<div id="sec:mcmc-configuration" class="section level2 hasAnchor" number="7.2">
<h2><span class="header-section-number">7.2</span> The MCMC configuration<a href="cha-mcmc.html#sec:mcmc-configuration" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The MCMC configuration contains information needed for building an MCMC. When no customization is needed, one can jump directly to the <code>buildMCMC</code> step below. An MCMC configuration is an object of class <code>MCMCconf</code>, which includes:</p>
<ul>
<li>The model on which the MCMC will operate</li>
<li>The model nodes which will be sampled (updated) by the MCMC</li>
<li>The samplers and their internal configurations, called control parameters</li>
<li>Two sets of variables that will be monitored (recorded) during execution of the MCMC and thinning intervals for how often each set will be recorded. Two sets are allowed because it can be useful to monitor different variables at different intervals</li>
</ul>
<div id="sec:default-mcmc-conf" class="section level3 hasAnchor" number="7.2.1">
<h3><span class="header-section-number">7.2.1</span> Default MCMC configuration<a href="cha-mcmc.html#sec:default-mcmc-conf" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Assuming we have a model named <code>Rmodel</code>, the following will generate a default MCMC configuration:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="cha-mcmc.html#cb144-1" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel)</span></code></pre></div>
<p>The default configuration will contain a single sampler for each node in the model, and the default ordering follows the topological ordering of the model.</p>
<div id="default-assignment-of-sampler-algorithms" class="section level4 hasAnchor" number="7.2.1.1">
<h4><span class="header-section-number">7.2.1.1</span> Default assignment of sampler algorithms<a href="cha-mcmc.html#default-assignment-of-sampler-algorithms" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The default sampler assigned to a stochastic node is determined by the following, in order of precedence:</p>
<ol style="list-style-type: decimal">
<li>If the node has no data nodes in its entire downstream dependency network, a <code>posterior_predictive</code> sampler is assigned. This sampler updates the node in question and all downstream stochastic nodes by simulating new values from each node’s conditional distribution. As of version 0.13.0, the operation of the <code>posterior_predictive</code> sampler has changed in order to improve MCMC mixing. See Section <a href="cha-mcmc.html#sec:post-pred-sampling">7.2.1.2</a>.</li>
<li>If the node has a conjugate relationship between its prior distribution and the distributions of its stochastic dependents, a <code>conjugate</code> (`Gibbs’) sampler is assigned.</li>
<li>If the node follows a multinomial distribution, then a <code>RW_multinomial</code> sampler is assigned. This is a discrete random-walk sampler in the space of multinomial outcomes.</li>
<li>If a node follows a Dirichlet distribution, then a <code>RW_dirichlet</code> sampler is assigned. This is a random walk sampler in the space of the simplex defined by the Dirichlet.</li>
<li>If a node follows an LKJ correlation distribution, then a <code>RW_block_lkj_corr_cholesky</code> sampler is assigned. This is a block random walk sampler in a transformed space where the transformation uses the signed stickbreaking approach described in Section 10.12 of <span class="citation">Stan Development Team (<a href="references.html#ref-Stan_Lang_2021">2021b</a>)</span>.</li>
<li>If the node follows any other multivariate distribution, then a <code>RW_block</code> sampler is assigned for all elements. This is a Metropolis-Hastings adaptive random-walk sampler with a multivariate normal proposal <span class="citation">(<a href="references.html#ref-Roberts_Sahu_1997">Roberts and Sahu 1997</a>)</span>.</li>
<li>If the node is binary-valued (strictly taking values 0 or 1), then a <code>binary</code> sampler is assigned. This sampler calculates the conditional probability for both possible node values and draws the new node value from the conditional distribution, in effect making a Gibbs sampler.</li>
<li>If the node is otherwise discrete-valued, then a <code>slice</code> sampler is assigned <span class="citation">(<a href="references.html#ref-Neal2003">R. M. Neal 2003</a>)</span>.</li>
<li>If none of the above criteria are satisfied, then a <code>RW</code> sampler is assigned. This is a Metropolis-Hastings adaptive random-walk sampler with a univariate normal proposal distribution.</li>
</ol>
<!-- These sampler assignment rules can be inspected, reordered, and easily modified using the system option `nimbleOptions("MCMCdefaultSamplerAssignmentRules")` and customized  `samplerAssignmentRules` objects. -->
<p>Details of each sampler and its control parameters can be found by invoking <code>help(samplers)</code>.</p>
<!-- #### Sampler assignment rules

The behavior of `configureMCMC` can be customized to control how samplers are assigned.  A new set of sampler assignment rules can be created using `samplerAssignmentRules`, which can be modified using the `addRule` and `reorder` methods, then passed as an argument to `configureMCMC`.  Alternatively, the default behavior of `configureMCMC` can be altered by setting the system option `MCMCdefaultSamplerAssignmentRules` to a custom `samplerAssignmentRules` object.  See `help(samplerAssignmentRules)` for details. -->
</div>
<div id="sec:post-pred-sampling" class="section level4 hasAnchor" number="7.2.1.2">
<h4><span class="header-section-number">7.2.1.2</span> Sampling posterior predictive nodes<a href="cha-mcmc.html#sec:post-pred-sampling" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A posterior predictive node is a node that is not itself data and has no data nodes in its entire downstream (descendant) dependency network. Such nodes play no role in inference for model parameters but have often been included in BUGS models to accomplish posterior predictive checks and similar calculations.</p>
<p>As of version 0.13.0, NIMBLE’s handling of posterior predictive nodes in MCMC sampling has changed in order to improve MCMC mixing. Samplers for nodes that are not posterior predictive nodes no longer condition on the values of the posterior predictive nodes. This produces a valid MCMC over the posterior distribution marginalizing over the posterior predictive nodes. This MCMC will generally mix better than an MCMC that conditions on the values of posterior predictive nodes, by reducing the dimensionality of the parameter space and removing the dependence between the sampled nodes and the posterior predictive nodes. At the end of each MCMC iteration, the posterior predictive nodes are sampled by <code>posterior_predictive</code> sampler(s) based on their conditional distribution(s).</p>
</div>
<div id="options-to-control-default-sampler-assignments" class="section level4 hasAnchor" number="7.2.1.3">
<h4><span class="header-section-number">7.2.1.3</span> Options to control default sampler assignments<a href="cha-mcmc.html#options-to-control-default-sampler-assignments" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Very basic control of default sampler assignments is provided via two arguments to <code>configureMCMC</code>. The <code>useConjugacy</code> argument controls whether conjugate samplers are assigned when possible, and the <code>multivariateNodesAsScalars</code> argument controls whether scalar elements of multivariate nodes are sampled individually. See <code>help(configureMCMC)</code> for usage details.
<!--- % The following optional control arguments to `configureMCMC()` may be used to override the default assignment of sampler algorithms: --></p>
<!--- 
%%   1.[useConjugacy (default `TRUE`)] If `TRUE`, conjugate samplers will be assigned to nodes determined to be in conjugate relationships.  If `FALSE`, no conjugate samplers will be assigned.
%   1.[multivariateNodesAsScalars (default `FALSE`)]  If `TRUE`, then independent scalar random walk Metropolis-Hastings samplers (`RW`) will be assigned to all scalar components comprising multivariate nodes.  This contrasts the default behavior of a single block sampler being assigned to multivariate nodes.  Regardless of the value of this argument, conjugate samplers will be assigned to conjugate (scalar and multivariate nodes), provided `useConjugacy = TRUE`. -->
</div>
<div id="default-monitors" class="section level4 hasAnchor" number="7.2.1.4">
<h4><span class="header-section-number">7.2.1.4</span> Default monitors<a href="cha-mcmc.html#default-monitors" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The default MCMC configuration includes monitors on all top-level stochastic nodes of the model. Only variables that are monitored will have their samples saved for use outside of the MCMC. MCMC configurations include two sets of monitors, each with different thinning intervals. By default, the second set of monitors (<code>monitors2</code>) is empty.</p>
</div>
<div id="automated-parameter-blocking" class="section level4 hasAnchor" number="7.2.1.5">
<h4><span class="header-section-number">7.2.1.5</span> Automated parameter blocking<a href="cha-mcmc.html#automated-parameter-blocking" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p></p>
<p>The default configuration may be replaced by one generated from an automated parameter blocking algorithm. This algorithm determines groupings of model nodes that, when jointly sampled with a <code>RW_block</code> sampler, increase overall MCMC efficiency. Overall efficiency is defined as the effective sample size of the slowest-mixing node divided by computation time. This is done by:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb145-1"><a href="cha-mcmc.html#cb145-1" tabindex="-1"></a>autoBlockConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">autoBlock =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Note that this using <code>autoBlock = TRUE</code> compiles and runs MCMCs, progressively exploring different sampler assignments, so it takes some time and generates some output. It is most useful for determining effective blocking strategies that can be re-used for later runs. The additional control argument <code>autoIt</code> may also be provided to indicate the number of MCMC samples to be used in each trial of the automated blocking procedure (default 20,000).</p>
</div>
</div>
<div id="sec:customizing-mcmc-conf" class="section level3 hasAnchor" number="7.2.2">
<h3><span class="header-section-number">7.2.2</span> Customizing the MCMC configuration<a href="cha-mcmc.html#sec:customizing-mcmc-conf" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The MCMC configuration may be customized in a variety of ways, either through additional named arguments to <code>configureMCMC</code> or by calling methods of an existing <code>MCMCconf</code> object.</p>
<div id="controlling-which-nodes-to-sample" class="section level4 hasAnchor" number="7.2.2.1">
<h4><span class="header-section-number">7.2.2.1</span> Controlling which nodes to sample<a href="cha-mcmc.html#controlling-which-nodes-to-sample" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>One can create an MCMC configuration with default samplers on just a particular set of nodes using the <code>nodes</code> argument to <code>configureMCMC</code>. The value for the <code>nodes</code> argument may be a character vector containing node and/or variable names. In the case of a variable name, a default sampler will be added for all stochastic nodes in the variable. The order of samplers will match the order of <code>nodes</code>. Any deterministic nodes will be ignored.</p>
<p>If a data node is included in <code>nodes</code>, <em>it will be assigned a sampler</em>. This is the only way in which a default sampler may be placed on a data node and will result in overwriting data values in the node.</p>
</div>
<div id="creating-an-empty-configuration" class="section level4 hasAnchor" number="7.2.2.2">
<h4><span class="header-section-number">7.2.2.2</span> Creating an empty configuration<a href="cha-mcmc.html#creating-an-empty-configuration" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>If you plan to customize the choice of all samplers, it can be useful to obtain a configuration with no sampler assignments at all. This can be done by any of <code>nodes = NULL</code>, <code>nodes = character()</code>, or <code>nodes = list()</code>.</p>
<!-- #### Overriding the default sampler assignment rules
The default rules used for assigning samplers to model nodes can be overridden using the `rules` argument to `configureMCMC`.  This argument must be an object of class `samplerAssignmentRules`, which defines an ordered set of rules for assigning samplers.  Rules can be modified and reordered, to give different precedence to particular samplers, or to assign user-defined samplers (see section \@ref(sec:user-samplers)).  The following example creates a new set of rules (which initially contains the default assignment rules), reorders the rules, adds a new rule, then uses these rules to create an MCMC configuration object.

r, mcmcconfrules, eval=FALSE}
my_rules <- samplerAssignmentRules()
my_rules$reorder(c(8, 1:7))
my_rules$addRule(condition = quote(model$getDistribution(node) == "dmnorm"),
                 sampler = new_dmnorm_sampler)
mcmcConf <- configureMCMC(Rmodel, rules = my_rules)

In addition, the default behavior of `configureMCMC` can be altered by setting the system option `nimbleOptions(MCMCdefaultSamplerAssignmentRules = my_rules)`, or reset to the original default behavior using `nimbleOptions(MCMCdefaultSamplerAssignmentRules = samplerAssignmentRules())`. -->
</div>
<div id="overriding-the-default-sampler-control-list-values" class="section level4 hasAnchor" number="7.2.2.3">
<h4><span class="header-section-number">7.2.2.3</span> Overriding the default sampler control list values<a href="cha-mcmc.html#overriding-the-default-sampler-control-list-values" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The default values of control list elements for all sampling algorithms may be overridden through use of the <code>control</code> argument to <code>configureMCMC</code>, which should be a named list.
Named elements in the <code>control</code> argument will be used for all default samplers and any subsequent sampler added via <code>addSampler</code> (see below). For example, the following will create the default MCMC configuration, except all <code>RW</code> samplers will have their initial <code>scale</code> set to 3, and none of the samplers (<code>RW</code>, or otherwise) will be adaptive.</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="cha-mcmc.html#cb146-1" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">control =</span> <span class="fu">list</span>(<span class="at">scale =</span> <span class="dv">3</span>, <span class="at">adaptive =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<p>When adding samplers to a configuration using <code>addSampler</code>, the default control list can also be over-ridden.</p>
</div>
<div id="adding-samplers-to-the-configuration-addsampler" class="section level4 hasAnchor" number="7.2.2.4">
<h4><span class="header-section-number">7.2.2.4</span> Adding samplers to the configuration: <em>addSampler</em><a href="cha-mcmc.html#adding-samplers-to-the-configuration-addsampler" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Additional samplers may be added to a configuration using the <code>addSampler</code> method of the <code>MCMCconf</code> object. The <code>addSampler</code> method has two modes of operation, determined by the <code>default</code> argument.</p>
<p>When <code>default = TRUE</code>, <code>addSampler</code> will assign NIMBLE’s default sampling algorithm for each node specified following the same protocol as <code>configureMCMC</code>. This may include conjugate samplers, multivariate samplers, or otherwise, also using additional arguments to guide the selection process (for example, <code>useConjugacy</code> and <code>multivariateNodesAsScalars</code>). In this mode of operation, the <code>type</code> argument is not used.</p>
<p>When <code>default = FALSE</code>, or when this argument is omitted, <code>addSampler</code> uses the <code>type</code> argument to specify the precise sampler to assign. Instances of this particular sampler are assigned to all nodes specified. The <code>type</code> argument may be provided as a character string or a nimbleFunction object. Valid character strings are indicated in <code>help(samplers)</code> (do not include <code>"sampler_"</code>). Added samplers can be labeled with a <code>name</code> argument, which is used in output of <code>printSamplers</code>. Writing a new sampler as a nimbleFunction is covered in Section <a href="cha-progr-with-models.html#sec:user-samplers">15.5</a>.</p>
<p>Regardless of the mode of operation, nodes are specified using either the <code>target</code> or the <code>nodes</code> argument. The <code>target</code> argument does not undergo expansion to constituent nodes (unless <code>default = TRUE</code>), and thus only a single sampler is added. The <code>nodes</code> argument is always expanded to the underlying nodes, and separate samplers are added for each node. Eithe argument is provided as a character vector. Newly added samplers will be appended to the end of current sampler list. Adding a sampler for a node will <em>not</em> remove existing samplers operating on that node.</p>
<p>The hierarchy of precedence for control list elements for added samplers is:</p>
<ol style="list-style-type: decimal">
<li>The <code>control</code> list argument provided to <code>addSampler</code>;</li>
<li>The original <code>control</code> list argument provided to <code>configureMCMC</code>;</li>
<li>The default values, as defined in the sampling algorithm <code>setup</code> function.</li>
</ol>
<p>See <code>help(addSampler)</code> for more details.</p>
</div>
<div id="printing-re-ordering-modifying-and-removing-samplers-printsamplers-removesamplers-setsamplers-and-getsamplerdefinition" class="section level4 hasAnchor" number="7.2.2.5">
<h4><span class="header-section-number">7.2.2.5</span> Printing, re-ordering, modifying and removing samplers: <em>printSamplers</em>, <em>removeSamplers</em>, <em>setSamplers</em>, and <em>getSamplerDefinition</em><a href="cha-mcmc.html#printing-re-ordering-modifying-and-removing-samplers-printsamplers-removesamplers-setsamplers-and-getsamplerdefinition" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The current, ordered, list of all samplers in the MCMC configuration may be printed by calling the <code>printSamplers</code> method. When you want to see only samplers acting on specific model nodes or variables, provide those names as an argument to <code>printSamplers</code>. The <code>printSamplers</code> method accepts arguments controlling the level of detail displayed as discussed in its R help information.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="cha-mcmc.html#cb147-1" tabindex="-1"></a><span class="co"># Print all samplers</span></span>
<span id="cb147-2"><a href="cha-mcmc.html#cb147-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>()</span>
<span id="cb147-3"><a href="cha-mcmc.html#cb147-3" tabindex="-1"></a></span>
<span id="cb147-4"><a href="cha-mcmc.html#cb147-4" tabindex="-1"></a><span class="co"># Print all samplers operating on node &quot;a[1]&quot;,</span></span>
<span id="cb147-5"><a href="cha-mcmc.html#cb147-5" tabindex="-1"></a><span class="co"># or any of the &quot;beta[]&quot; variables</span></span>
<span id="cb147-6"><a href="cha-mcmc.html#cb147-6" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="fu">c</span>(<span class="st">&quot;a[1]&quot;</span>, <span class="st">&quot;beta&quot;</span>))</span>
<span id="cb147-7"><a href="cha-mcmc.html#cb147-7" tabindex="-1"></a></span>
<span id="cb147-8"><a href="cha-mcmc.html#cb147-8" tabindex="-1"></a><span class="co"># Print all conjugate and slice samplers</span></span>
<span id="cb147-9"><a href="cha-mcmc.html#cb147-9" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="at">type =</span> <span class="fu">c</span>(<span class="st">&quot;conjugate&quot;</span>, <span class="st">&quot;slice&quot;</span>))</span>
<span id="cb147-10"><a href="cha-mcmc.html#cb147-10" tabindex="-1"></a></span>
<span id="cb147-11"><a href="cha-mcmc.html#cb147-11" tabindex="-1"></a><span class="co"># Print all RW samplers operating on &quot;x&quot;</span></span>
<span id="cb147-12"><a href="cha-mcmc.html#cb147-12" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="st">&quot;x&quot;</span>, <span class="at">type =</span> <span class="st">&quot;RW&quot;</span>)</span>
<span id="cb147-13"><a href="cha-mcmc.html#cb147-13" tabindex="-1"></a></span>
<span id="cb147-14"><a href="cha-mcmc.html#cb147-14" tabindex="-1"></a><span class="co"># Print the first 100 samplers</span></span>
<span id="cb147-15"><a href="cha-mcmc.html#cb147-15" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>)</span>
<span id="cb147-16"><a href="cha-mcmc.html#cb147-16" tabindex="-1"></a></span>
<span id="cb147-17"><a href="cha-mcmc.html#cb147-17" tabindex="-1"></a><span class="co"># Print all samplers in their order of execution</span></span>
<span id="cb147-18"><a href="cha-mcmc.html#cb147-18" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="at">executionOrder =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Samplers may be removed from the configuration object using <code>removeSamplers</code>, which accepts a character vector of node or variable names, or a numeric vector of indices.</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="cha-mcmc.html#cb148-1" tabindex="-1"></a><span class="co"># Remove all samplers acting on &quot;x&quot; or any component of it</span></span>
<span id="cb148-2"><a href="cha-mcmc.html#cb148-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">removeSamplers</span>(<span class="st">&quot;x&quot;</span>)</span>
<span id="cb148-3"><a href="cha-mcmc.html#cb148-3" tabindex="-1"></a></span>
<span id="cb148-4"><a href="cha-mcmc.html#cb148-4" tabindex="-1"></a><span class="co"># Remove all samplers acting on &quot;alpha[1]&quot; and &quot;beta[1]&quot;</span></span>
<span id="cb148-5"><a href="cha-mcmc.html#cb148-5" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">removeSamplers</span>(<span class="fu">c</span>(<span class="st">&quot;alpha[1]&quot;</span>, <span class="st">&quot;beta[1]&quot;</span>))</span>
<span id="cb148-6"><a href="cha-mcmc.html#cb148-6" tabindex="-1"></a></span>
<span id="cb148-7"><a href="cha-mcmc.html#cb148-7" tabindex="-1"></a><span class="co"># Remove the first five samplers</span></span>
<span id="cb148-8"><a href="cha-mcmc.html#cb148-8" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">removeSamplers</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span>
<span id="cb148-9"><a href="cha-mcmc.html#cb148-9" tabindex="-1"></a></span>
<span id="cb148-10"><a href="cha-mcmc.html#cb148-10" tabindex="-1"></a><span class="co"># Providing no argument removes all samplers</span></span>
<span id="cb148-11"><a href="cha-mcmc.html#cb148-11" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">removeSamplers</span>()</span></code></pre></div>
<p>Samplers to retain may be specified reordered using <code>setSamplers</code>, which also accepts a character vector of node or variable names, or a numeric vector of indices.</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb149-1"><a href="cha-mcmc.html#cb149-1" tabindex="-1"></a><span class="co"># Set the list of samplers to those acting on any components of the</span></span>
<span id="cb149-2"><a href="cha-mcmc.html#cb149-2" tabindex="-1"></a><span class="co"># model variables &quot;x&quot;, &quot;y&quot;, or &quot;z&quot;.</span></span>
<span id="cb149-3"><a href="cha-mcmc.html#cb149-3" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplers</span>(<span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))</span>
<span id="cb149-4"><a href="cha-mcmc.html#cb149-4" tabindex="-1"></a></span>
<span id="cb149-5"><a href="cha-mcmc.html#cb149-5" tabindex="-1"></a><span class="co"># Set the list of samplers to only those acting on model nodes</span></span>
<span id="cb149-6"><a href="cha-mcmc.html#cb149-6" tabindex="-1"></a><span class="co"># &quot;alpha[1]&quot;, &quot;alpha[2]&quot;, ..., &quot;alpha[10]&quot;</span></span>
<span id="cb149-7"><a href="cha-mcmc.html#cb149-7" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplers</span>(<span class="st">&quot;alpha[1:10]&quot;</span>)</span>
<span id="cb149-8"><a href="cha-mcmc.html#cb149-8" tabindex="-1"></a></span>
<span id="cb149-9"><a href="cha-mcmc.html#cb149-9" tabindex="-1"></a><span class="co"># Truncate the current list of samplers to the first 10 and the 100th</span></span>
<span id="cb149-10"><a href="cha-mcmc.html#cb149-10" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplers</span>(<span class="at">ind =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="dv">100</span>))</span></code></pre></div>
<p>The nimbleFunction definition underlying a particular sampler may be viewed using the <code>getSamplerDefinition</code> method, using the sampler index as an argument. A node name argument may also be supplied, in which case the definition of the first sampler acting on that node is returned. In all cases, <code>getSamplerDefinition</code> only returns the definition of the <em>first</em> sampler specified either by index or node name.</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="cha-mcmc.html#cb150-1" tabindex="-1"></a><span class="co"># Return the definition of the third sampler in the mcmcConf object</span></span>
<span id="cb150-2"><a href="cha-mcmc.html#cb150-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">getSamplerDefinition</span>(<span class="dv">3</span>)</span>
<span id="cb150-3"><a href="cha-mcmc.html#cb150-3" tabindex="-1"></a></span>
<span id="cb150-4"><a href="cha-mcmc.html#cb150-4" tabindex="-1"></a><span class="co"># Return the definition of the first sampler acting on node &quot;x&quot;,</span></span>
<span id="cb150-5"><a href="cha-mcmc.html#cb150-5" tabindex="-1"></a><span class="co"># or the first of any indexed nodes comprising the variable &quot;x&quot;</span></span>
<span id="cb150-6"><a href="cha-mcmc.html#cb150-6" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">getSamplerDefinition</span>(<span class="st">&quot;x&quot;</span>)</span></code></pre></div>
</div>
<div id="customizing-individual-sampler-configurations-getsamplers-setsamplers-setname-setsamplerfunction-settarget-and-setcontrol" class="section level4 hasAnchor" number="7.2.2.6">
<h4><span class="header-section-number">7.2.2.6</span> Customizing individual sampler configurations: <em>getSamplers</em>, <em>setSamplers</em>, <em>setName</em>, <em>setSamplerFunction</em>, <em>setTarget</em>, and <em>setControl</em><a href="cha-mcmc.html#customizing-individual-sampler-configurations-getsamplers-setsamplers-setname-setsamplerfunction-settarget-and-setcontrol" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Each sampler in an <code>MCMCconf</code> object is represented by a sampler configuration as a <code>samplerConf</code> object. Each <code>samplerConf</code> is a reference class object containing the following (required) fields: <code>name</code> (a character string), <code>samplerFunction</code> (a valid nimbleFunction sampler), <code>target</code> (the model node to be sampled), and <code>control</code> (list of control arguments). The <code>MCMCconf</code> method <code>getSamplers</code> allows access to the <code>samplerConf</code> objects. These can be modified and then passed as an argument to <code>setSamplers</code> to over-write the current list of samplers in the MCMC configuration object. However, no checking of the validity of this modified list is performed; if the list of samplerConf objects is corrupted to be invalid, incorrect behavior will result at the time of calling <code>buildMCMC</code>. The fields of a <code>samplerConf</code> object can be modified using the access functions <code>setName(name)</code>, <code>setSamplerFunction(fun)</code>, <code>setTarget(target, model)</code>, and <code>setControl(control)</code>.</p>
<p>Here are some examples:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="cha-mcmc.html#cb151-1" tabindex="-1"></a><span class="co"># retrieve samplerConf list</span></span>
<span id="cb151-2"><a href="cha-mcmc.html#cb151-2" tabindex="-1"></a>samplerConfList <span class="ot">&lt;-</span> mcmcConf<span class="sc">$</span><span class="fu">getSamplers</span>()</span>
<span id="cb151-3"><a href="cha-mcmc.html#cb151-3" tabindex="-1"></a></span>
<span id="cb151-4"><a href="cha-mcmc.html#cb151-4" tabindex="-1"></a><span class="co"># change the name of the first sampler</span></span>
<span id="cb151-5"><a href="cha-mcmc.html#cb151-5" tabindex="-1"></a>samplerConfList[[<span class="dv">1</span>]]<span class="sc">$</span><span class="fu">setName</span>(<span class="st">&quot;newNameForThisSampler&quot;</span>)</span>
<span id="cb151-6"><a href="cha-mcmc.html#cb151-6" tabindex="-1"></a></span>
<span id="cb151-7"><a href="cha-mcmc.html#cb151-7" tabindex="-1"></a><span class="co"># change the sampler function of the second sampler,</span></span>
<span id="cb151-8"><a href="cha-mcmc.html#cb151-8" tabindex="-1"></a><span class="co"># assuming existance of a nimbleFunction &#39;anotherSamplerNF&#39;,</span></span>
<span id="cb151-9"><a href="cha-mcmc.html#cb151-9" tabindex="-1"></a><span class="co"># which represents a valid nimbleFunction sampler.</span></span>
<span id="cb151-10"><a href="cha-mcmc.html#cb151-10" tabindex="-1"></a>samplerConfList[[<span class="dv">2</span>]]<span class="sc">$</span><span class="fu">setSamplerFunction</span>(anotherSamplerNF)</span>
<span id="cb151-11"><a href="cha-mcmc.html#cb151-11" tabindex="-1"></a></span>
<span id="cb151-12"><a href="cha-mcmc.html#cb151-12" tabindex="-1"></a><span class="co"># change the &#39;adaptive&#39; element of the control list of the third sampler</span></span>
<span id="cb151-13"><a href="cha-mcmc.html#cb151-13" tabindex="-1"></a>control <span class="ot">&lt;-</span> samplerConfList[[<span class="dv">3</span>]]<span class="sc">$</span>control</span>
<span id="cb151-14"><a href="cha-mcmc.html#cb151-14" tabindex="-1"></a>control<span class="sc">$</span>adaptive <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb151-15"><a href="cha-mcmc.html#cb151-15" tabindex="-1"></a>samplerConfList[[<span class="dv">3</span>]]<span class="sc">$</span><span class="fu">setControl</span>(control)</span>
<span id="cb151-16"><a href="cha-mcmc.html#cb151-16" tabindex="-1"></a></span>
<span id="cb151-17"><a href="cha-mcmc.html#cb151-17" tabindex="-1"></a><span class="co"># change the target node of the fourth sampler</span></span>
<span id="cb151-18"><a href="cha-mcmc.html#cb151-18" tabindex="-1"></a>samplerConfList[[<span class="dv">4</span>]]<span class="sc">$</span><span class="fu">setTarget</span>(<span class="st">&quot;y&quot;</span>, model)   <span class="co"># model argument required</span></span>
<span id="cb151-19"><a href="cha-mcmc.html#cb151-19" tabindex="-1"></a></span>
<span id="cb151-20"><a href="cha-mcmc.html#cb151-20" tabindex="-1"></a><span class="co"># use this modified list of samplerConf objects in the MCMC configuration</span></span>
<span id="cb151-21"><a href="cha-mcmc.html#cb151-21" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplers</span>(samplerConfList)</span></code></pre></div>
</div>
<div id="customizing-the-sampler-execution-order" class="section level4 hasAnchor" number="7.2.2.7">
<h4><span class="header-section-number">7.2.2.7</span> Customizing the sampler execution order<a href="cha-mcmc.html#customizing-the-sampler-execution-order" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The ordering of sampler execution can be controlled as well. This allows for sampler functions to execute multiple times within a single MCMC iteration, or the execution of different sampler functions to be interleaved with one another.</p>
<p>The sampler execution order is set using the function <code>setSamplerExecutionOrder</code>, and the current ordering of execution is retrieved using <code>getSamplerExecutionOrder</code>. For example, assuming the MCMC configuration object <code>mcmcConf</code> contains five samplers:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="cha-mcmc.html#cb152-1" tabindex="-1"></a><span class="co"># first sampler to execute twice, in succession:</span></span>
<span id="cb152-2"><a href="cha-mcmc.html#cb152-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplerExecutionOrder</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>))</span>
<span id="cb152-3"><a href="cha-mcmc.html#cb152-3" tabindex="-1"></a></span>
<span id="cb152-4"><a href="cha-mcmc.html#cb152-4" tabindex="-1"></a><span class="co"># first sampler to execute multiple times, interleaved:</span></span>
<span id="cb152-5"><a href="cha-mcmc.html#cb152-5" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplerExecutionOrder</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>))</span>
<span id="cb152-6"><a href="cha-mcmc.html#cb152-6" tabindex="-1"></a></span>
<span id="cb152-7"><a href="cha-mcmc.html#cb152-7" tabindex="-1"></a><span class="co"># fourth sampler to execute 10 times, only</span></span>
<span id="cb152-8"><a href="cha-mcmc.html#cb152-8" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplerExecutionOrder</span>(<span class="fu">rep</span>(<span class="dv">4</span>, <span class="dv">10</span>))</span>
<span id="cb152-9"><a href="cha-mcmc.html#cb152-9" tabindex="-1"></a></span>
<span id="cb152-10"><a href="cha-mcmc.html#cb152-10" tabindex="-1"></a><span class="co"># omitting the argument to setSamplerExecutionOrder()</span></span>
<span id="cb152-11"><a href="cha-mcmc.html#cb152-11" tabindex="-1"></a><span class="co"># resets the ordering to each sampler executing once, sequentially</span></span>
<span id="cb152-12"><a href="cha-mcmc.html#cb152-12" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setSamplerExecutionOrder</span>()</span>
<span id="cb152-13"><a href="cha-mcmc.html#cb152-13" tabindex="-1"></a></span>
<span id="cb152-14"><a href="cha-mcmc.html#cb152-14" tabindex="-1"></a><span class="co"># retrieve the current ordering of sampler execution</span></span>
<span id="cb152-15"><a href="cha-mcmc.html#cb152-15" tabindex="-1"></a>ordering <span class="ot">&lt;-</span> mcmcConf<span class="sc">$</span><span class="fu">getSamplerExecutionOrder</span>()</span>
<span id="cb152-16"><a href="cha-mcmc.html#cb152-16" tabindex="-1"></a></span>
<span id="cb152-17"><a href="cha-mcmc.html#cb152-17" tabindex="-1"></a><span class="co"># print the sampler functions in the order of execution</span></span>
<span id="cb152-18"><a href="cha-mcmc.html#cb152-18" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>(<span class="at">executionOrder =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
</div>
<div id="monitors-and-thinning-intervals-printmonitors-getmonitors-setmonitors-addmonitors-resetmonitors-and-setthin" class="section level4 hasAnchor" number="7.2.2.8">
<h4><span class="header-section-number">7.2.2.8</span> Monitors and thinning intervals: <em>printMonitors</em>, <em>getMonitors</em>, <em>setMonitors</em>, <em>addMonitors</em>, <em>resetMonitors</em> and <em>setThin</em><a href="cha-mcmc.html#monitors-and-thinning-intervals-printmonitors-getmonitors-setmonitors-addmonitors-resetmonitors-and-setthin" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>An MCMC configuration object contains two independent sets of variables to monitor, each with their own thinning interval: <code>thin</code> corresponding to <code>monitors</code>, and <code>thin2</code> corresponding to <code>monitors2</code>. Monitors operate at the <em>variable</em> level. Only entire model variables may be monitored. Specifying a monitor on a <em>node</em>, e.g., <code>x[1]</code>, will result in the entire variable <code>x</code> being monitored.</p>
<p>The variables specified in <code>monitors</code> and <code>monitors2</code> will be recorded (with thinning interval <code>thin</code>) into objects called <code>mvSamples</code> and <code>mvSamples2</code>, contained within the MCMC object. These are both <em>modelValues</em> objects; modelValues are NIMBLE data structures used to store multiple sets of values of model variables<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>. These can be accessed as the member data <code>mvSamples</code> and <code>mvSamples2</code> of the MCMC object, and they can be converted to matrices using <code>as.matrix</code> or lists using <code>as.list</code> (see Section <a href="cha-mcmc.html#sec:extracting-samples">7.7</a>).</p>
<p>Monitors may be added to the MCMC configuration either in the original call to <code>configureMCMC</code> or using the <code>addMonitors</code> method:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="cha-mcmc.html#cb153-1" tabindex="-1"></a><span class="co"># Using an argument to configureMCMC</span></span>
<span id="cb153-2"><a href="cha-mcmc.html#cb153-2" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">monitors =</span> <span class="fu">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>), </span>
<span id="cb153-3"><a href="cha-mcmc.html#cb153-3" tabindex="-1"></a>                          <span class="at">monitors2 =</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb153-4"><a href="cha-mcmc.html#cb153-4" tabindex="-1"></a></span>
<span id="cb153-5"><a href="cha-mcmc.html#cb153-5" tabindex="-1"></a><span class="co"># Calling a member method of the mcmcconf object</span></span>
<span id="cb153-6"><a href="cha-mcmc.html#cb153-6" tabindex="-1"></a><span class="co"># This results in the same monitors as above</span></span>
<span id="cb153-7"><a href="cha-mcmc.html#cb153-7" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">addMonitors</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>)</span>
<span id="cb153-8"><a href="cha-mcmc.html#cb153-8" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">addMonitors2</span>(<span class="st">&quot;x&quot;</span>)</span></code></pre></div>
<p>A new set of monitor variables can be added to the MCMC configuration, overwriting the current monitors, using the <code>setMonitors</code> method:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="cha-mcmc.html#cb154-1" tabindex="-1"></a><span class="co"># Replace old monitors, now monitor &quot;delta&quot; and &quot;gamma&quot; only</span></span>
<span id="cb154-2"><a href="cha-mcmc.html#cb154-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setMonitors</span>(<span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;delta&quot;</span>)</span></code></pre></div>
<p>Similarly, either thinning interval may be set at either step:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb155-1"><a href="cha-mcmc.html#cb155-1" tabindex="-1"></a><span class="co"># Using an argument to configureMCMC</span></span>
<span id="cb155-2"><a href="cha-mcmc.html#cb155-2" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">thin =</span> <span class="dv">1</span>, <span class="at">thin2 =</span> <span class="dv">100</span>)</span>
<span id="cb155-3"><a href="cha-mcmc.html#cb155-3" tabindex="-1"></a></span>
<span id="cb155-4"><a href="cha-mcmc.html#cb155-4" tabindex="-1"></a><span class="co"># Calling a member method of the mcmcConf object</span></span>
<span id="cb155-5"><a href="cha-mcmc.html#cb155-5" tabindex="-1"></a><span class="co"># This results in the same thinning intervals as above</span></span>
<span id="cb155-6"><a href="cha-mcmc.html#cb155-6" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setThin</span>(<span class="dv">1</span>)</span>
<span id="cb155-7"><a href="cha-mcmc.html#cb155-7" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">setThin2</span>(<span class="dv">100</span>)</span></code></pre></div>
<p>The current lists of monitors and thinning intervals may be displayed using the <code>printMonitors</code> method. Both sets of monitors (<code>monitors</code> and <code>monitors2</code>) may be reset to empty character vectors by calling the <code>resetMonitors</code> method. The methods <code>getMonitors</code> and <code>getMonitors2</code> return the currently specified <code>monitors</code> and <code>monitors2</code> as character vectors.</p>
</div>
<div id="monitoring-model-log-probabilities" class="section level4 hasAnchor" number="7.2.2.9">
<h4><span class="header-section-number">7.2.2.9</span> Monitoring model log-probabilities<a href="cha-mcmc.html#monitoring-model-log-probabilities" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>To record model log-probabilities from an MCMC, one can add monitors for <em>logProb</em> variables (which begin with the prefix <code>logProb_</code>) that correspond to variables with (any) stochastic nodes. For example, to record and extract log-probabilities for the variables <code>alpha</code>, <code>sigma_mu</code>, and <code>Y</code>:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="cha-mcmc.html#cb156-1" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">enableWAIC =</span> <span class="cn">TRUE</span>)</span>
<span id="cb156-2"><a href="cha-mcmc.html#cb156-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">addMonitors</span>(<span class="st">&quot;logProb_alpha&quot;</span>, <span class="st">&quot;logProb_sigma_mu&quot;</span>, <span class="st">&quot;logProb_Y&quot;</span>)</span>
<span id="cb156-3"><a href="cha-mcmc.html#cb156-3" tabindex="-1"></a>Rmcmc <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf)</span>
<span id="cb156-4"><a href="cha-mcmc.html#cb156-4" tabindex="-1"></a>Cmodel <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmodel)</span>
<span id="cb156-5"><a href="cha-mcmc.html#cb156-5" tabindex="-1"></a>Cmcmc <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmcmc, <span class="at">project =</span> Rmodel)</span>
<span id="cb156-6"><a href="cha-mcmc.html#cb156-6" tabindex="-1"></a>Cmcmc<span class="sc">$</span><span class="fu">run</span>(<span class="dv">10000</span>)</span>
<span id="cb156-7"><a href="cha-mcmc.html#cb156-7" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(Cmcmc<span class="sc">$</span>mvSamples)</span></code></pre></div>
<p>The <code>samples</code> matrix will contain both MCMC samples and model log-probabilities.</p>
</div>
<div id="using-numeric-samples-to-define-a-prior-distribution" class="section level4 hasAnchor" number="7.2.2.10">
<h4><span class="header-section-number">7.2.2.10</span> Using numeric samples to define a prior distribution<a href="cha-mcmc.html#using-numeric-samples-to-define-a-prior-distribution" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A set of numeric samples, perhaps generated from another MCMC algorithm, can be used to define the prior distribution of model nodes. This is accomplished using the <code>prior_samples</code> MCMC sampler. When assigning the <code>prior_samples</code> sampler to a <code>target</code> node, you must also provide a vector of numeric values (when <code>target</code> is a scalar node), or a matrix of values in the multidimenional case. A new value (or rows of values) is selected either sequentially (or randomly) from this numeric vector/matrix, and assigned into the <code>target</code> node on each MCMC iteration. See <code>help(prior_samples)</code> for more details:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb157-1"><a href="cha-mcmc.html#cb157-1" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel)</span>
<span id="cb157-2"><a href="cha-mcmc.html#cb157-2" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">addSampler</span>(<span class="at">target =</span> <span class="st">&#39;theta&#39;</span>, <span class="at">type =</span> <span class="st">&#39;prior_samples&#39;</span>, <span class="at">samples =</span> <span class="fu">rnorm</span>(<span class="dv">100</span>))</span></code></pre></div>
</div>
</div>
</div>
<div id="sec:build-compile-mcmc" class="section level2 hasAnchor" number="7.3">
<h2><span class="header-section-number">7.3</span> Building and compiling the MCMC<a href="cha-mcmc.html#sec:build-compile-mcmc" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once the MCMC configuration object has been created, and customized to one’s liking, it may be used to build an MCMC function:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="cha-mcmc.html#cb158-1" tabindex="-1"></a>Rmcmc <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf)</span></code></pre></div>
<p><code>buildMCMC</code> is a nimbleFunction. The returned object <code>Rmcmc</code> is an instance of the nimbleFunction specific to configuration <code>mcmcConf</code> (and of course its associated model).</p>
<p>Note that if you would like to be able to calculate the WAIC of the model, you should usually set <code>enableWAIC = TRUE</code> as an argument to<code>configureMCMC</code> (or to <code>buildMCMC</code> if not using <code>configureMCMC</code>), or set <code>nimbleOptions(MCMCenableWAIC = TRUE)</code>, which will enable WAIC calculations for all subsequently built MCMC functions. For more information on WAIC calculations, including situations in which you can calculate WAIC without having set <code>enableWAIC = TRUE</code> see Section <a href="cha-mcmc.html#sec:WAIC">7.8</a> or <code>help(waic)</code> in R.</p>
<p>When no customization is needed, one can skip <code>configureMCMC</code> and simply provide a model object to <code>buildMCMC</code>. The following two MCMC functions will be identical:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb159-1"><a href="cha-mcmc.html#cb159-1" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel)   <span class="co"># default MCMC configuration</span></span>
<span id="cb159-2"><a href="cha-mcmc.html#cb159-2" tabindex="-1"></a>Rmcmc1 <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf)</span>
<span id="cb159-3"><a href="cha-mcmc.html#cb159-3" tabindex="-1"></a></span>
<span id="cb159-4"><a href="cha-mcmc.html#cb159-4" tabindex="-1"></a>Rmcmc2 <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(Rmodel)   <span class="co"># uses the default configuration for Rmodel</span></span></code></pre></div>
<p>For speed of execution, we usually want to compile the MCMC function to C++ (as is the case for other NIMBLE functions). To do so, we use <code>compileNimble</code>. If the model has already been compiled, it should be provided as the <code>project</code> argument so the MCMC will be part of the same compiled project. A typical compilation call looks like:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="cha-mcmc.html#cb160-1" tabindex="-1"></a>Cmcmc <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmcmc, <span class="at">project =</span> Rmodel)</span></code></pre></div>
<p>Alternatively, if the model has not already been compiled, they can be compiled together in one line:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb161-1"><a href="cha-mcmc.html#cb161-1" tabindex="-1"></a>Cmcmc <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmodel, Rmcmc)</span></code></pre></div>
<p>Note that if you compile the MCMC with another object (the model in this case), you’ll need to explicitly refer to the MCMC component of the resulting object to be able to run the MCMC:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb162-1"><a href="cha-mcmc.html#cb162-1" tabindex="-1"></a>Cmcmc<span class="sc">$</span>Rmcmc<span class="sc">$</span><span class="fu">run</span>(<span class="at">niter =</span> <span class="dv">1000</span>)</span></code></pre></div>
</div>
<div id="sec:initMCMC" class="section level2 hasAnchor" number="7.4">
<h2><span class="header-section-number">7.4</span> Initializing MCMC<a href="cha-mcmc.html#sec:initMCMC" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>To see how to provide initial values, see <code>help(runMCMC)</code>, <code>help(nimbleMCMC)</code>, or <code>help(nimbleModel)</code>.</p>
<p>It is often important to provide valid and reasonable initial values to an MCMC, either as fixed values or via an initialization function.</p>
<p>Not doing so can cause slow convergence or even failure of an MCMC algorithm (e.g., if the values the model is initialized with are not valid). When starting an MCMC, when NIMBLE encounters a missing parameter value, it simulates from the prior distribution. NIMBLE can be more sensitive to missing or bad starting values than some MCMC packages.</p>
<p>The following cases are particularly important to consider when initializing:</p>
<ul>
<li>In a model with flat priors (i.e., using <code>x~dflat()</code> or <code>x~dhalfflat()</code>), NIMBLE cannot generate initial values from those priors.</li>
<li>In a model with diffuse priors, initializing from the prior can give unreasonable/extreme initial values.</li>
<li>In a model with stochastic indices (e.g., <code>x[idx[i]]</code> with <code>idx[i]</code> unknown), those indices should have (valid) initial values.</li>
<li>In a model with constraints (via <code>dconstraint</code>), the model should be initialized such that the constraints are satisfied.</li>
<li>In a model with censoring (via <code>dinterval</code>), the initial value(s) of <code>t</code> in <code>dinterval</code> for the censored node(s) should be consistent with the censoring that is specified.</li>
</ul>
<p>That said, some MCMC algorithms (such a conjugate samplers) don’t use the initial values, so flat or diffuse priors on nodes assigned such samplers will not be a problem with regard to initialization.</p>
<p>Many user questions and problems end up being related to missing or bad initial values. Some suggestions for diagnosing initialization problems include:</p>
<ul>
<li>Run <code>model$initializeInfo()</code> to find uninitialized nodes.</li>
<li>Run <code>model$calculate()</code> to see if the full model log probability density can be calculated (values of <code>-Inf</code>, <code>NA</code>, <code>NaN</code> indicate there are missing or invalid initial values).</li>
<li>To debug the specific node(s) whose initial value(s) are causing problems, run <code>model$calculate(nodes)</code> on specific <code>nodes</code> to find their log probability density values, looking look for values of <code>-Inf</code>, <code>NA</code>, or <code>NaN</code>.</li>
<li>For the node(s) with invalid log probability density, inspect the values of the node(s) and parameter(s) of the distribution(s) assigned to those node(s). You can inspect values of a variable in the model using natural R syntax, <code>model$variable_name</code>.</li>
<li>With a compiled or uncompiled model, you can run the model initialization (but no MCMC iterations) with <code>mcmc$run(niter = 0)</code>. Then inspect the values of model variables to see the results of initialization.</li>
</ul>
</div>
<div id="sec:runMCMC" class="section level2 hasAnchor" number="7.5">
<h2><span class="header-section-number">7.5</span> User-friendly execution of MCMC algorithms: <em>runMCMC</em><a href="cha-mcmc.html#sec:runMCMC" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Once an MCMC algorithm has been created using <code>buildMCMC</code>, the function <code>runMCMC</code> can be used to run multiple chains and extract posterior samples, summary statistics and/or a WAIC value. This is a simpler approach to executing an MCMC algorithm, than the process of executing and extracting samples as described in Sections <a href="cha-mcmc.html#sec:executing-the-mcmc-algorithm">7.6</a> and <a href="cha-mcmc.html#sec:extracting-samples">7.7</a>.</p>
<p><code>runMCMC</code> also provides several user-friendly options such as burn-in, thinning, running multiple chains, and different initial values for each chain. However, using <code>runMCMC</code> does not support several lower-level options, such as timing the individual samplers internal to the MCMC, continuing an existing MCMC run (picking up where it left off), or modifying the sampler execution ordering.</p>
<p><code>runMCMC</code> takes arguments that will control the following aspects of the MCMC:
<!---  `runMCMC` has one mandatory argument: the (compiled or uncompiled) MCMC algorithm.  Other arguments to `runMCMC` are available to control: --></p>
<ul>
<li>Number of iterations in each chain;</li>
<li>Number of chains;</li>
<li>Number of burn-in samples to discard from each chain;</li>
<li>Thinning interval for recording samples;</li>
<li>Initial values, or a function for generating initial values for each chain;</li>
<li>Setting the random number seed;</li>
<li>Returning the posterior samples as a <code>coda</code> <code>mcmc</code> object;</li>
<li>Returning summary statistics calculated from each chains; and</li>
<li>Returning a WAIC value calculated using (post-burn-in) samples from all chains.</li>
</ul>
<!---  See `help(runMCMC)` for details of these arguments. -->
<!---  Other features of the MCMC can still be customized when using `runMCMC`, which is done using the MCMC configuration object.  This includes setting monitors, or customizing samplers (see Section \@ref(sec:customizing-mcmc-conf)).  The MCMC configuration object is then used to create an MCMC algorithm, which is compiled and passed as an argument to `runMCMC`. -->
<!---  When running a single chain, `runMCMC` returns a matrix of MCMC samples (as described in Section \@ref(sec:extracting-samples)).  When running multiple chains, a list of sample matrices is returned.  Using the argument `samplesAsCodaMCMC=TRUE`, a `coda` `mcmc` object, or in the case of multiple chains, a `coda` `mcmc.list` object is returned instead. -->
<p>The following examples demonstrate some uses of <code>runMCMC</code>, and assume the existence of <code>Cmcmc</code>, a compiled MCMC algorithm.</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="cha-mcmc.html#cb163-1" tabindex="-1"></a><span class="co"># run a single chain, and return a matrix of samples</span></span>
<span id="cb163-2"><a href="cha-mcmc.html#cb163-2" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc)</span>
<span id="cb163-3"><a href="cha-mcmc.html#cb163-3" tabindex="-1"></a></span>
<span id="cb163-4"><a href="cha-mcmc.html#cb163-4" tabindex="-1"></a><span class="co"># run three chains of 10000 samples, discard initial burn-in of 1000,</span></span>
<span id="cb163-5"><a href="cha-mcmc.html#cb163-5" tabindex="-1"></a><span class="co"># record samples thereafter using a thinning interval of 10,</span></span>
<span id="cb163-6"><a href="cha-mcmc.html#cb163-6" tabindex="-1"></a><span class="co"># and return of list of sample matrices</span></span>
<span id="cb163-7"><a href="cha-mcmc.html#cb163-7" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">niter=</span><span class="dv">10000</span>, <span class="at">nburnin=</span><span class="dv">1000</span>, <span class="at">thin=</span><span class="dv">10</span>, <span class="at">nchains=</span><span class="dv">3</span>)</span>
<span id="cb163-8"><a href="cha-mcmc.html#cb163-8" tabindex="-1"></a></span>
<span id="cb163-9"><a href="cha-mcmc.html#cb163-9" tabindex="-1"></a><span class="co"># run three chains, returning posterior samples, summary statistics,</span></span>
<span id="cb163-10"><a href="cha-mcmc.html#cb163-10" tabindex="-1"></a><span class="co"># and the WAIC value</span></span>
<span id="cb163-11"><a href="cha-mcmc.html#cb163-11" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">nchains =</span> <span class="dv">3</span>, <span class="at">summary =</span> <span class="cn">TRUE</span>, <span class="at">WAIC =</span> <span class="cn">TRUE</span>)</span>
<span id="cb163-12"><a href="cha-mcmc.html#cb163-12" tabindex="-1"></a></span>
<span id="cb163-13"><a href="cha-mcmc.html#cb163-13" tabindex="-1"></a><span class="co"># run two chains, and specify the initial values for each</span></span>
<span id="cb163-14"><a href="cha-mcmc.html#cb163-14" tabindex="-1"></a>initsList <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="fu">list</span>(<span class="at">mu =</span> <span class="dv">1</span>, <span class="at">sigma =</span> <span class="dv">1</span>),</span>
<span id="cb163-15"><a href="cha-mcmc.html#cb163-15" tabindex="-1"></a>                  <span class="fu">list</span>(<span class="at">mu =</span> <span class="dv">2</span>, <span class="at">sigma =</span> <span class="dv">10</span>))</span>
<span id="cb163-16"><a href="cha-mcmc.html#cb163-16" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">nchains =</span> <span class="dv">2</span>, <span class="at">inits =</span> initsList)</span>
<span id="cb163-17"><a href="cha-mcmc.html#cb163-17" tabindex="-1"></a></span>
<span id="cb163-18"><a href="cha-mcmc.html#cb163-18" tabindex="-1"></a><span class="co"># run ten chains of 100,000 iterations each, using a function to </span></span>
<span id="cb163-19"><a href="cha-mcmc.html#cb163-19" tabindex="-1"></a><span class="co"># generate initial values and a fixed random number seed for each chain.</span></span>
<span id="cb163-20"><a href="cha-mcmc.html#cb163-20" tabindex="-1"></a><span class="co"># only return summary statistics from each chain; not all the samples.</span></span>
<span id="cb163-21"><a href="cha-mcmc.html#cb163-21" tabindex="-1"></a>initsFunction <span class="ot">&lt;-</span> <span class="cf">function</span>()</span>
<span id="cb163-22"><a href="cha-mcmc.html#cb163-22" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">mu =</span> <span class="fu">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">sigma =</span> <span class="fu">runif</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">100</span>))</span>
<span id="cb163-23"><a href="cha-mcmc.html#cb163-23" tabindex="-1"></a>mcmc.out <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">niter =</span> <span class="dv">100000</span>, <span class="at">nchains =</span> <span class="dv">10</span>,</span>
<span id="cb163-24"><a href="cha-mcmc.html#cb163-24" tabindex="-1"></a>                    <span class="at">inits =</span> initsFunction, <span class="at">setSeed =</span> <span class="cn">TRUE</span>,</span>
<span id="cb163-25"><a href="cha-mcmc.html#cb163-25" tabindex="-1"></a>                    <span class="at">samples =</span> <span class="cn">FALSE</span>, <span class="at">summary =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>See <code>help(runMCMC)</code> for further details.</p>
</div>
<div id="sec:executing-the-mcmc-algorithm" class="section level2 hasAnchor" number="7.6">
<h2><span class="header-section-number">7.6</span> Running the MCMC<a href="cha-mcmc.html#sec:executing-the-mcmc-algorithm" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The MCMC algorithm (either the compiled or uncompiled version) can be executed using the member method <code>mcmc$run</code> (see <code>help(buildMCMC)</code> in R). The <code>run</code> method has one required argument, <code>niter</code>, the number of iterations to be run.</p>
<p>The <code>run</code> method has optional arguments <code>nburnin</code>, <code>thin</code> and <code>thin2</code>. These can be used to specify the number of pre-thinning burn-in samples to discard, and the post-burnin thinning intervals for recording samples (corresponding to <code>monitors</code> and <code>monitors2</code>). If either <code>thin</code> and <code>thin2</code> are provided, they will override the thinning intervals that were specified in the original MCMC configuration object.</p>
<div id="sec:mcmc-rerun" class="section level3 hasAnchor" number="7.6.1">
<h3><span class="header-section-number">7.6.1</span> Rerunning versus restarting an MCMC<a href="cha-mcmc.html#sec:mcmc-rerun" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The <code>run</code> method has an optional <code>reset</code> argument. When <code>reset = TRUE</code> (the default value), the following occurs prior to running the MCMC:</p>
<ol style="list-style-type: decimal">
<li>All model nodes are checked and filled or updated as needed, in valid (topological) order. If a stochastic node is missing a value, it is populated using a call to <code>simulate</code> and its log probability value is calculated. The values of deterministic nodes are calculated from their parent nodes. If any right-hand-side-only nodes (e.g., explanatory variables) are missing a value, an error results.</li>
<li>All MCMC sampler functions are reset to their initial state: the initial values of any sampler control parameters (e.g., <code>scale</code>, <code>sliceWidth</code>, or <code>propCov</code>) are reset to their initial values, as were specified by the original MCMC configuration.</li>
<li>The internal modelValues objects <code>mvSamples</code> and <code>mvSamples2</code> are each resized to the appropriate length for holding the requested number of samples (<code>niter/thin</code>, and <code>niter/thin2</code>, respectively).</li>
</ol>
<p>This means that one can begin a new run of an existing MCMC without having to rebuild or recompile the model or the MCMC. This can be helpful if one wants to use the same model and MCMC configuration, but with different initial values, different values of data nodes (but which nodes are data nodes must be the same), changes to covariate values(or other non-data, non-parameter values) in the model, or a different number of MCMC iterations, thinning interval or burn-in.</p>
<p>In contrast, when <code>mcmc$run(niter, reset = FALSE)</code> is called, the MCMC picks up from where it left off, continuing the previous chain and expanding the output as needed. No values in the model are checked or altered, and sampler functions are not reset to their initial states. (Similarly, if using WAIC, one can use <code>resetWAIC = FALSE</code> so that the WAIC calculation is based on all the samples from the expanded set of samples.)</p>
<p>The <code>run</code> method also has an optional <code>resetMV</code> argument. This argument is only considered when<code>'reset</code> is set to <code>FALSE</code>. When <code>mcmc$run(niter, reset = FALSE, resetMV = TRUE)</code> is called the internal modelValues objects <code>mvSamples</code> and <code>mvSamples2</code> are each resized to the appropriate length for holding the requested number of samples (<code>niter/thin</code>, and <code>niter/thin2</code>, respectively) and the MCMC carries on from where it left off. In other words, the previously obtained samples are deleted (e.g. to reduce memory usage) prior to continuing the MCMC. The default value of <code>resetMV</code> is <code>FALSE</code>.</p>
</div>
<div id="sec:sampler-time" class="section level3 hasAnchor" number="7.6.2">
<h3><span class="header-section-number">7.6.2</span> Measuring sampler computation times: <em>getTimes</em><a href="cha-mcmc.html#sec:sampler-time" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you want to obtain the computation time spent in each sampler, you can set <code>time=TRUE</code> as a run-time argument and then use the method <code>getTimes()</code> obtain the times. For example,</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="cha-mcmc.html#cb164-1" tabindex="-1"></a>Cmcmc<span class="sc">$</span><span class="fu">run</span>(niter, <span class="at">time =</span> <span class="cn">TRUE</span>)</span>
<span id="cb164-2"><a href="cha-mcmc.html#cb164-2" tabindex="-1"></a>Cmcmc<span class="sc">$</span><span class="fu">getTimes</span>()</span></code></pre></div>
<p>will return a vector of the total time spent in each sampler, measured in seconds.
<!---  
%### Modifying the order of sampler execution: `samplerExecutionOrder` \label{sec:runtime-sampler-execution-order}
%The order in which the MCMC sampler functions execute can also be specified at MCMC runtime.  This is done using the argument `samplerExecutionOrder`.  Providing this runtime argument will override any modified execution ordering that was specified in the MCMC configuration.  For example,
% code chunk example (with eval=FALSE):
## interleave execution of the first sampler with other sampler functions 
% Cmcmc$run(niter, samplerExecutionOrder = c(1, 2, 1, 3, 1, 4, 1, 5))
--></p>
</div>
<div id="assessing-the-adaption-process-of-rw-and-rw_block-samplers" class="section level3 hasAnchor" number="7.6.3">
<h3><span class="header-section-number">7.6.3</span> Assessing the adaption process of <em>RW</em> and <em>RW_block</em> samplers<a href="cha-mcmc.html#assessing-the-adaption-process-of-rw-and-rw_block-samplers" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you’d like to see the evolution (over the iterations) of the acceptance proportion and proposal scale information, you can use some internal methods provided by NIMBLE, after setting two options to make the history accessible. Here we assume that <code>cMCMC</code> is the compiled MCMC object and <code>idx</code> is the numeric index of the sampler function you want to access from amongst the list of sampler functions that are part of the MCMC.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb165-1"><a href="cha-mcmc.html#cb165-1" tabindex="-1"></a><span class="do">## set options to make history accessible</span></span>
<span id="cb165-2"><a href="cha-mcmc.html#cb165-2" tabindex="-1"></a><span class="fu">nimbleOptions</span>(<span class="at">buildInterfacesForCompiledNestedNimbleFunctions =</span> <span class="cn">TRUE</span>)</span>
<span id="cb165-3"><a href="cha-mcmc.html#cb165-3" tabindex="-1"></a><span class="fu">nimbleOptions</span>(<span class="at">MCMCsaveHistory =</span> <span class="cn">TRUE</span>)</span>
<span id="cb165-4"><a href="cha-mcmc.html#cb165-4" tabindex="-1"></a><span class="do">## Next, set up and run your MCMC.</span></span>
<span id="cb165-5"><a href="cha-mcmc.html#cb165-5" tabindex="-1"></a><span class="do">## Now access the history information:</span></span>
<span id="cb165-6"><a href="cha-mcmc.html#cb165-6" tabindex="-1"></a>Cmcmc<span class="sc">$</span>samplerFunctions[[idx]]<span class="sc">$</span><span class="fu">getScaleHistory</span>()</span>
<span id="cb165-7"><a href="cha-mcmc.html#cb165-7" tabindex="-1"></a>Cmcmc<span class="sc">$</span>samplerFunctions[[idx]]<span class="sc">$</span><span class="fu">getAcceptanceHistory</span>()</span>
<span id="cb165-8"><a href="cha-mcmc.html#cb165-8" tabindex="-1"></a>Cmcmc<span class="sc">$</span>samplerFunctions[[idx]]<span class="sc">$</span><span class="fu">getPropCovHistory</span>()   <span class="do">## only for RW_block</span></span></code></pre></div>
<p>Note that modifying elements of the control list may greatly
affect the performance of the <code>RW_block</code> sampler. In particular, the sampler
can take a long time to find a good proposal covariance when the
elements being sampled are not on the same scale. We recommend
providing an informed value for ‘propCov’ in this case (possibly
simply a diagonal matrix that approximates the relative scales),
as well as possibly providing a value of ‘scale’ that errs on the
side of being too small. You may also consider decreasing
‘adaptFactorExponent’ and/or ‘adaptInterval’, as doing so has
greatly improved performance in some cases.</p>
</div>
</div>
<div id="sec:extracting-samples" class="section level2 hasAnchor" number="7.7">
<h2><span class="header-section-number">7.7</span> Extracting MCMC samples<a href="cha-mcmc.html#sec:extracting-samples" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>After executing the MCMC, the output samples can be extracted as follows:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="cha-mcmc.html#cb166-1" tabindex="-1"></a>mvSamples <span class="ot">&lt;-</span> mcmc<span class="sc">$</span>mvSamples</span>
<span id="cb166-2"><a href="cha-mcmc.html#cb166-2" tabindex="-1"></a>mvSamples2 <span class="ot">&lt;-</span> mcmc<span class="sc">$</span>mvSamples2</span></code></pre></div>
<p>These <em>modelValues</em> objects can be converted into matrices using <code>as.matrix</code> or lists using <code>as.list</code>:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb167-1"><a href="cha-mcmc.html#cb167-1" tabindex="-1"></a>samplesMatrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(mvSamples)</span>
<span id="cb167-2"><a href="cha-mcmc.html#cb167-2" tabindex="-1"></a>samplesList <span class="ot">&lt;-</span> <span class="fu">as.list</span>(mvSamples)</span>
<span id="cb167-3"><a href="cha-mcmc.html#cb167-3" tabindex="-1"></a>samplesMatrix2 <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(mvSamples2)</span>
<span id="cb167-4"><a href="cha-mcmc.html#cb167-4" tabindex="-1"></a>samplesList2 <span class="ot">&lt;-</span> <span class="fu">as.list</span>(mvSamples2)</span></code></pre></div>
<p>The column names of the matrices will be the node names of nodes in the monitored variables. Then, for example, the mean of the samples for node <code>x[2]</code> could be calculated as:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="cha-mcmc.html#cb168-1" tabindex="-1"></a><span class="fu">mean</span>(samplesMatrix[, <span class="st">&quot;x[2]&quot;</span>])</span></code></pre></div>
<p>The list version will contain an element for each variable that will be the size and shape of the variable with an additional index for MCMC iteration. By default MCMC iteration will be the first index, but including <code>iterationAsLastIndex = TRUE</code> will make it the last index.</p>
<p>Obtaining samples as matrices or lists is most common, but see Section <a href="cha-data-structures.html#sec:modelValues-struct">14.1</a> for more about programming with modelValues objects, especially if you want to write nimbleFunctions to use the samples.</p>
</div>
<div id="sec:WAIC" class="section level2 hasAnchor" number="7.8">
<h2><span class="header-section-number">7.8</span> Calculating WAIC<a href="cha-mcmc.html#sec:WAIC" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The WAIC <span class="citation">(<a href="references.html#ref-Watanabe_2010">Watanabe 2010</a>)</span> can be calculated from the posterior samples produced during the MCMC algorithm. Users have two options to calculate WAIC. The main approach requires enabling WAIC when setting up the MCMC and allows access to a variety of ways to calculate WAIC. This approach does not require that any specific monitors be set<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a> because the WAIC is calculated in an online manner, accumulating the necessary quantities to calculate WAIC as the MCMC is run.</p>
<p>The second approach allows one to calculate the WAIC after an MCMC has been run using an MCMC object or matrix (or dataframe) containing the posterior samples, but it requires the user to have correctly specified the monitored variables and only provides the default way to calculate WAIC. An advantage of the second approach is that one can specify additional burnin beyond that specified for the MCMC.</p>
<p>Here we first discuss the main approach and then close the section by showing the second approach. Specific details of the syntax are provided in <code>help(waic)</code>.</p>
<p>To enable WAIC for the first approach, the argument <code>enableWAIC = TRUE</code> must be supplied to <code>configureMCMC</code> (or to <code>buildMCMC</code> if not using <code>configureWAIC</code>), or the <code>MCMCenableWAIC</code> NIMBLE option must have been set to <code>TRUE</code>.</p>
<p>The WAIC (as well as the pWAIC and lppd values) is extracted by the member method <code>mcmc$getWAIC</code> (see <code>help(waic)</code> in R for more details) or is available as the <code>WAIC</code> element of the <code>runMCMC</code> or <code>nimbleMCMC</code> output lists. One can use the member method <code>mcmc$getWAICdetails</code> for additional quantities related to WAIC that are discussed below.</p>
<p>Note that there is not a unique value of WAIC for a model. WAIC is calculated from
Equations 5, 12, and 13 in <span class="citation">Gelman, Hwang, and Vehtari (<a href="references.html#ref-Gelman_etal_2014">2014</a>)</span> (i.e., using WAIC2), as discussed in detail in <span class="citation">Hug and Paciorek (<a href="references.html#ref-Hug_Paciorek_2021">2021</a>)</span>. Therefore, NIMBLE provides
user control over how WAIC is calculated in two ways.</p>
<p>First, by default NIMBLE provides the conditional WAIC, namely the version of WAIC where all parameters directly involved in the likelihood are treated as <span class="math inline">\(\theta\)</span> for the purposes of Equation 5 from <span class="citation">Gelman, Hwang, and Vehtari (<a href="references.html#ref-Gelman_etal_2014">2014</a>)</span>. Users can request the marginal WAIC (see <span class="citation">Ariyo et al. (<a href="references.html#ref-Ariyo_etal_2019">2020</a>)</span>), namely the version of WAIC where latent variables are integrated over (i.e., using a marginal likelihood). This is done by providing the <code>waicControl</code> list with a <code>marginalizeNodes</code> element to <code>configureMCMC</code> or <code>buildMCMC</code> (when providing a model as the argument to <code>buildMCMC</code>). See <code>help(waic)</code> for more details.</p>
<p>Second, WAIC relies on a partition of the observations, i.e., ‘pointwise’ prediction. By default, in NIMBLE the sum over log pointwise predictive density values treats each data node as contributing a single value to the sum. When a data node is multivariate, that data node contributes a single value to the sum based on the joint density of the elements in the node. If one wants to group data nodes such that the joint density within each group is used, one can provide the <code>waicControl</code> list with a <code>dataGroups</code> element to <code>configureMCMC</code> or <code>buildMCMC</code> (when providing a model as the argument to <code>buildMCMC</code>). See <code>help(waic)</code> for more details.</p>
<p>Note that based on a limited set of simulation experiments in <span class="citation">Hug and Paciorek (<a href="references.html#ref-Hug_Paciorek_2021">2021</a>)</span>, our tentative recommendation is that users only use marginal WAIC if also using grouping.</p>
<p>Marginal WAIC requires using Monte Carlo simulation at each iteration of the MCMC to average over draws for the latent variables. To assess the stability of the marginal WAIC to the number of Monte Carlo iterations, one can examine how the WAIC changes with increasing iterations (up to the full number of iterations specified via the <code>nItsMarginal</code> element of the <code>waicControl</code> list) based on the <code>WAIC_partialMC</code>, <code>lppd_partialMC</code>, and <code>pWAIC_partialMC</code> elements of the detailed WAIC output.</p>
<p>For comparing WAIC between two models, <span class="citation">Vehtari, Gelman, and Gabry (<a href="references.html#ref-Vehtari_etal_2017">2017</a>)</span> discuss using the per-observation (more generally, per-data group) contributions to the overall WAIC values to get an approximate standard error for the difference in WAIC between the models. These element-wise values are available as the <code>WAIC_elements</code>, <code>lppd_elements</code>, and <code>pWAIC_elements</code> components of the detailed WAIC output.</p>
<p>The second overall approach to WAIC available in NIMBLE allows one to calculate WAIC post hoc after MCMC sampling using an MCMC object or matrix (or dataframe) containing posterior samples. Simply set up the MCMC and run it without enabling WAIC (but making sure to include in the monitors all stochastic parent nodes of the data nodes) and then use the function <code>calculateWAIC</code>, as shown in this example:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb169-1"><a href="cha-mcmc.html#cb169-1" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc, <span class="at">niter =</span> <span class="dv">10000</span>, <span class="at">nburnin =</span> <span class="dv">1000</span>)</span>
<span id="cb169-2"><a href="cha-mcmc.html#cb169-2" tabindex="-1"></a><span class="do">## Using calculateWAIC with an MCMC object</span></span>
<span id="cb169-3"><a href="cha-mcmc.html#cb169-3" tabindex="-1"></a><span class="fu">calculateWAIC</span>(Cmcmc)</span>
<span id="cb169-4"><a href="cha-mcmc.html#cb169-4" tabindex="-1"></a><span class="do">## Using calculateWAIC with a matrix of samples</span></span>
<span id="cb169-5"><a href="cha-mcmc.html#cb169-5" tabindex="-1"></a><span class="fu">calculateWAIC</span>(samples, model)</span>
<span id="cb169-6"><a href="cha-mcmc.html#cb169-6" tabindex="-1"></a><span class="do">## Specifying additional burnin, so only last 5000 (1000+4000) iterations used</span></span>
<span id="cb169-7"><a href="cha-mcmc.html#cb169-7" tabindex="-1"></a><span class="fu">calculateWAIC</span>(Cmcmc, <span class="at">burnin =</span> <span class="dv">4000</span>)</span></code></pre></div>
<p>This approach only provides conditional WAIC without any grouping of data nodes (though one can achieve grouping by grouping data nodes into multivariate nodes).</p>
</div>
<div id="k-fold-cross-validation" class="section level2 hasAnchor" number="7.9">
<h2><span class="header-section-number">7.9</span> k-fold cross-validation<a href="cha-mcmc.html#k-fold-cross-validation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The <code>runCrossValidate</code> function in NIMBLE performs k-fold cross-validation on a <code>nimbleModel</code> fit via MCMC. More information can be found by calling <code>help(runCrossValidate)</code>.</p>
</div>
<div id="sec:rjmcmc" class="section level2 hasAnchor" number="7.10">
<h2><span class="header-section-number">7.10</span> Variable selection using Reversible Jump MCMC<a href="cha-mcmc.html#sec:rjmcmc" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>A common method for Bayesian variable selection in regression-style problems is to define a space of different models and have MCMC sample over the models as well as the parameters for each model. The models differ in which explanatory variables are included. Often this idea is implemented in the BUGS language by writing the largest possible model and including indicator variables to turn regression parameters off and on (see model code below for an example of how indicator variables can be used). Foramally, that approach doesn’t sample between different models, instead embedding the models in one large model. However, that approach can result in poor mixing and require compromises in choices of prior distributions because a given regression parameter will sample from its prior when the corresponding indicator is 0. It is also computationally wasteful, because sampling effort will be spent on a coefficient even if it has no effect because the corresponding indicator is 0.</p>
<p>A different view of the problem is that the different combinations of coefficients represent models of different dimensions. Reversible Jump MCMC <span class="citation">(<a href="references.html#ref-Green_1995">Green 1995</a>)</span> (RJMCMC) is a general framework for MCMC simulation in which the dimension of the parameter space can vary between iterates of the Markov chain. The reversible jump sampler can be viewed as an extension of the Metropolis-Hastings algorithm onto more general state spaces. NIMBLE provides an implementation of RJMCMC for variable selection that requires the user to write the largest model of interest and supports use of indicator variables but formally uses RJMCMC sampling for better mixing and efficiency. When a coefficient is not in the model (or its indicator is 0), it will not be sampled, and it will therefore not follow its prior in that case.</p>
<p>In technical detail, given two models <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span> of possibly different dimensions, the core idea of RJMCMC is to remove the difference in the dimensions of models <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span> by supplementing the corresponding parameters <span class="math inline">\(\boldsymbol{\theta_1}\)</span> and <span class="math inline">\(\boldsymbol{\theta_2}\)</span> with auxiliary variables <span class="math inline">\(\boldsymbol{u}_{1 \rightarrow 2}\)</span> and <span class="math inline">\(\boldsymbol{u}_{2 \rightarrow 1}\)</span> such that <span class="math inline">\((\boldsymbol{\theta_1}, \boldsymbol{u}_{1 \rightarrow 2})\)</span> and <span class="math inline">\((\boldsymbol{\theta_2}, \boldsymbol{u}_{2 \rightarrow 1})\)</span>
are in bijection, <span class="math inline">\((\boldsymbol{\theta_2}, \boldsymbol{u}_{2 \rightarrow 1}) = \Psi(\boldsymbol{\theta_1}, \boldsymbol{u}_{1 \rightarrow 2})\)</span>. The corresponding Metropolis-Hastings acceptance probability is generalized accounting for the proposal density for the auxiliary variables.</p>
<p>NIMBLE implements RJMCMC for variable selection using a univariate normal distribution centered on 0 (or some fixed value) as the proposal density for parameters being added to the model. Two ways to set up models for RJMCMC are supported, which differ by whether the inclusion probabilities for each parameter are assumed known or must be written in the model:</p>
<ul>
<li>If the inclusion probabilities are assumed known, then RJMCMC may be used with regular model code, i.e. model code written without heed to variable selection.</li>
<li>If the inclusion probability is a parameter in the model, perhaps with its own prior, then RJMCMC requires that indicator variables be written in the model code. The indicator variables will be sampled using RJMCMC, but otherwise they are like any other nodes in the model.</li>
</ul>
<p>The steps to set up variable selection using RJMCMC are:</p>
<ol style="list-style-type: decimal">
<li>Write the model with indicator variables if needed.</li>
<li>Configure the MCMC as usual with <code>configureMCMC</code>.</li>
<li>Modify the resulting MCMC configuration object with <code>configureRJ</code>.</li>
</ol>
<p>The <code>configureRJ</code> function modifies the MCMC configuration to (1) assign samplers that turn on and off variable in the model and (2) modify the existing samplers for the regression coefficients to use ‘toggled’ versions. The toggled versions invoke the samplers only when corresponding variable is currently in the model. In the case where indicator variables are included in the model, sampling to turn on and off variables is done using <code>RJ_indicator</code> samplers. In the case where indicator variables are not included, sampling is done using <code>RJ_fixed_prior</code> samplers.</p>
<!--  See `help(configureRJ)` for details. -->
<p>In the following we provide an example for the two different model specifications.</p>
<div id="sec:rjmcmc-indicator" class="section level3 hasAnchor" number="7.10.1">
<h3><span class="header-section-number">7.10.1</span> Using indicator variables<a href="cha-mcmc.html#sec:rjmcmc-indicator" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Here we consider a normal linear regression in which two covariates <code>x1</code> and <code>x2</code> are candidates to be included in the model. The two corresponding coefficients are <code>beta1</code> and <code>beta2</code>. The indicator variables are <code>z1</code> and <code>z2</code>, and their inclusion probability is <code>psi</code>. As described below, one can also use vectors for a set of coefficients and corresponding indicator variables.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="cha-mcmc.html#cb170-1" tabindex="-1"></a><span class="do">## Linear regression with intercept and two covariates</span></span>
<span id="cb170-2"><a href="cha-mcmc.html#cb170-2" tabindex="-1"></a>code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb170-3"><a href="cha-mcmc.html#cb170-3" tabindex="-1"></a>  beta0 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb170-4"><a href="cha-mcmc.html#cb170-4" tabindex="-1"></a>  beta1 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb170-5"><a href="cha-mcmc.html#cb170-5" tabindex="-1"></a>  beta2 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb170-6"><a href="cha-mcmc.html#cb170-6" tabindex="-1"></a>  sigma <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>, <span class="dv">100</span>) </span>
<span id="cb170-7"><a href="cha-mcmc.html#cb170-7" tabindex="-1"></a>  z1 <span class="sc">~</span> <span class="fu">dbern</span>(psi)  <span class="do">## indicator variable associated with beta1</span></span>
<span id="cb170-8"><a href="cha-mcmc.html#cb170-8" tabindex="-1"></a>  z2 <span class="sc">~</span> <span class="fu">dbern</span>(psi)  <span class="do">## indicator variable associated with beta2</span></span>
<span id="cb170-9"><a href="cha-mcmc.html#cb170-9" tabindex="-1"></a>  psi <span class="sc">~</span> <span class="fu">dbeta</span>(<span class="dv">1</span>, <span class="dv">1</span>) <span class="do">## hyperprior on inclusion probability</span></span>
<span id="cb170-10"><a href="cha-mcmc.html#cb170-10" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) {</span>
<span id="cb170-11"><a href="cha-mcmc.html#cb170-11" tabindex="-1"></a>    Ypred[i] <span class="ot">&lt;-</span> beta0 <span class="sc">+</span> beta1 <span class="sc">*</span> z1 <span class="sc">*</span> x1[i] <span class="sc">+</span> beta2 <span class="sc">*</span> z2 <span class="sc">*</span> x2[i]</span>
<span id="cb170-12"><a href="cha-mcmc.html#cb170-12" tabindex="-1"></a>    Y[i] <span class="sc">~</span> <span class="fu">dnorm</span>(Ypred[i], <span class="at">sd =</span> sigma)</span>
<span id="cb170-13"><a href="cha-mcmc.html#cb170-13" tabindex="-1"></a>  }</span>
<span id="cb170-14"><a href="cha-mcmc.html#cb170-14" tabindex="-1"></a>})</span>
<span id="cb170-15"><a href="cha-mcmc.html#cb170-15" tabindex="-1"></a></span>
<span id="cb170-16"><a href="cha-mcmc.html#cb170-16" tabindex="-1"></a><span class="do">## simulate some data</span></span>
<span id="cb170-17"><a href="cha-mcmc.html#cb170-17" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb170-18"><a href="cha-mcmc.html#cb170-18" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb170-19"><a href="cha-mcmc.html#cb170-19" tabindex="-1"></a>x1 <span class="ot">&lt;-</span> <span class="fu">runif</span>(N, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb170-20"><a href="cha-mcmc.html#cb170-20" tabindex="-1"></a>x2 <span class="ot">&lt;-</span> <span class="fu">runif</span>(N, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="do">## this covariate is not included</span></span>
<span id="cb170-21"><a href="cha-mcmc.html#cb170-21" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N, <span class="fl">1.5</span> <span class="sc">+</span> <span class="dv">2</span> <span class="sc">*</span> x1, <span class="at">sd =</span> <span class="dv">1</span>)</span>
<span id="cb170-22"><a href="cha-mcmc.html#cb170-22" tabindex="-1"></a></span>
<span id="cb170-23"><a href="cha-mcmc.html#cb170-23" tabindex="-1"></a></span>
<span id="cb170-24"><a href="cha-mcmc.html#cb170-24" tabindex="-1"></a><span class="do">## build the model and configure default MCMC</span></span>
<span id="cb170-25"><a href="cha-mcmc.html#cb170-25" tabindex="-1"></a></span>
<span id="cb170-26"><a href="cha-mcmc.html#cb170-26" tabindex="-1"></a>RJexampleModel <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(code, <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">N =</span> N),</span>
<span id="cb170-27"><a href="cha-mcmc.html#cb170-27" tabindex="-1"></a>                              <span class="at">data =</span> <span class="fu">list</span>(<span class="at">Y =</span> Y, <span class="at">x1 =</span> x1, <span class="at">x2 =</span> x2), </span>
<span id="cb170-28"><a href="cha-mcmc.html#cb170-28" tabindex="-1"></a>                              <span class="at">inits =</span> <span class="fu">list</span>(<span class="at">beta0 =</span> <span class="dv">0</span>, <span class="at">beta1 =</span> <span class="dv">0</span>, <span class="at">beta2 =</span> <span class="dv">0</span>,</span>
<span id="cb170-29"><a href="cha-mcmc.html#cb170-29" tabindex="-1"></a>                              <span class="at">sigma =</span> <span class="fu">sd</span>(Y), <span class="at">z2 =</span> <span class="dv">1</span>, <span class="at">z1 =</span> <span class="dv">1</span>, <span class="at">psi =</span> <span class="fl">0.5</span>))</span>
<span id="cb170-30"><a href="cha-mcmc.html#cb170-30" tabindex="-1"></a></span>
<span id="cb170-31"><a href="cha-mcmc.html#cb170-31" tabindex="-1"></a>RJexampleConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(RJexampleModel)</span></code></pre></div>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb171-1"><a href="cha-mcmc.html#cb171-1" tabindex="-1"></a><span class="do">## For illustration, look at the default sampler assignments</span></span>
<span id="cb171-2"><a href="cha-mcmc.html#cb171-2" tabindex="-1"></a>RJexampleConf<span class="sc">$</span><span class="fu">printSamplers</span>()</span></code></pre></div>
<pre><code>## [1] conjugate_dnorm_dnorm_additive sampler: beta0
## [2] conjugate_dnorm_dnorm_linear sampler: beta1
## [3] conjugate_dnorm_dnorm_linear sampler: beta2
## [4] RW sampler: sigma
## [5] conjugate_dbeta_dbern_identity sampler: psi
## [6] binary sampler: z1
## [7] binary sampler: z2</code></pre>
<p>At this point we can modify the MCMC configuration object, <code>RJexampleConf</code>, to use reversible jump samplers for selection on <code>beta1</code> and <code>beta2</code>.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb173-1"><a href="cha-mcmc.html#cb173-1" tabindex="-1"></a><span class="fu">configureRJ</span>(<span class="at">conf =</span> RJexampleConf,     </span>
<span id="cb173-2"><a href="cha-mcmc.html#cb173-2" tabindex="-1"></a>            <span class="at">targetNodes =</span> <span class="fu">c</span>(<span class="st">&quot;beta1&quot;</span>, <span class="st">&quot;beta2&quot;</span>),</span>
<span id="cb173-3"><a href="cha-mcmc.html#cb173-3" tabindex="-1"></a>            <span class="at">indicatorNodes =</span> <span class="fu">c</span>(<span class="st">&#39;z1&#39;</span>, <span class="st">&#39;z2&#39;</span>),</span>
<span id="cb173-4"><a href="cha-mcmc.html#cb173-4" tabindex="-1"></a>            <span class="at">control =</span> <span class="fu">list</span>(<span class="at">mean =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="at">scale =</span> <span class="dv">2</span>))</span></code></pre></div>
<p>The <code>targetNodes</code> argument gives the coefficients (nodes) for which we want to do variable selection. The <code>indicatorNodes</code> gives the corresponding indicator nodes, ordered to match <code>targetNodes</code>. The <code>control</code> list gives the means and scale (standard deviation) for normal reversible jump proposals for <code>targetNodes</code>. The means will typically be 0 (by default <code>mean = 0</code> and <code>scale = 1</code>), but they could be anything. An optional <code>control</code> element called <code>fixedValue</code> can be provided in the non-indicator setting; this gives the value taken by nodes in <code>targetNodes</code> when they are out of the model (by default, <code>fixedValue</code> is 0).
All <code>control</code> elements can be scalars or vectors. A scalar values will be used for all <code>targetNodes</code>. A vector value must be of equal length as <code>targetNodes</code> and will be used in order.</p>
<p>To use RJMCMC on a vector of coefficients with a corresponding vector of indicator variables, simply provide the variable names for <code>targetNodes</code> and <code>indicatorNodes</code>. For example, <code>targetNodes = "beta"</code> is equivalent to <code>targetNodes = c("beta[1]", "beta[2]")</code> and <code>indicatorNodes = "z"</code> is equivalent to <code>indicatorNodes = c("z[1]", "z[2]")</code>. Expansion of variable names into a vector of node names will occur as described in Section <a href="cha-using-models.html#sec:arbitr-coll-nodes">13.3.1.1</a>. When using this method, <em>both</em> arguments must be provided as variable names to be expanded.</p>
<p>Next we can see the result of <code>configureRJ</code> by printing the modified list of samplers:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="cha-mcmc.html#cb174-1" tabindex="-1"></a>RJexampleConf<span class="sc">$</span><span class="fu">printSamplers</span>()</span></code></pre></div>
<pre><code>## [1] conjugate_dnorm_dnorm_additive sampler: beta0
## [2] RW sampler: sigma
## [3] conjugate_dbeta_dbern_identity sampler: psi
## [4] RJ_indicator sampler: z1,  mean: 0,  scale: 2,  targetNode: beta1
## [5] RJ_toggled sampler: beta1,  samplerType: conjugate_dnorm_dnorm_linear
## [6] RJ_indicator sampler: z2,  mean: 0,  scale: 2,  targetNode: beta2
## [7] RJ_toggled sampler: beta2,  samplerType: conjugate_dnorm_dnorm_linear</code></pre>
<p>An <code>RJ_indicator</code> sampler was assigned to each of <code>z[1]</code> and <code>z[2]</code> in place of the <code>binary</code> sampler, while the samplers for <code>beta[1]</code>and <code>beta[2]</code> have been changed to <code>RJ_toggled</code> samplers. The latter samplers contain the original samplers, in this case <code>conjugate_dnorm_dnorm</code> samplers, and use them only when the corresponding indicator variable is equal to <span class="math inline">\(1\)</span> (i.e., when the coefficient is in the model).</p>
<p>Notice that the order of the samplers has changed, since <code>configureRJ</code> calls <code>removeSampler</code> for nodes in <code>targetNodes</code> and <code>indicatorNodes</code>, and subsequently <code>addSampler</code>, which appends the sampler to the end of current sampler list. Order can be modified by using <code>setSamplers</code>.</p>
<p>Also note that <code>configureRJ</code> modifies the MCMC configuration (first argument) and returns <code>NULL</code>.</p>
</div>
<div id="sec:rjmcmc-no-indicator" class="section level3 hasAnchor" number="7.10.2">
<h3><span class="header-section-number">7.10.2</span> Without indicator variables<a href="cha-mcmc.html#sec:rjmcmc-no-indicator" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We consider the same regression setting, but without the use of indicator variables and with fixed probabilities of including each coefficient in the model.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb176-1"><a href="cha-mcmc.html#cb176-1" tabindex="-1"></a><span class="do">## Linear regression with intercept and two covariates</span></span>
<span id="cb176-2"><a href="cha-mcmc.html#cb176-2" tabindex="-1"></a>code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb176-3"><a href="cha-mcmc.html#cb176-3" tabindex="-1"></a>  beta0 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb176-4"><a href="cha-mcmc.html#cb176-4" tabindex="-1"></a>  beta1 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb176-5"><a href="cha-mcmc.html#cb176-5" tabindex="-1"></a>  beta2 <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb176-6"><a href="cha-mcmc.html#cb176-6" tabindex="-1"></a>  sigma <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>, <span class="dv">100</span>)</span>
<span id="cb176-7"><a href="cha-mcmc.html#cb176-7" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) {</span>
<span id="cb176-8"><a href="cha-mcmc.html#cb176-8" tabindex="-1"></a>    Ypred[i] <span class="ot">&lt;-</span> beta0 <span class="sc">+</span> beta1 <span class="sc">*</span> x1[i] <span class="sc">+</span> beta2 <span class="sc">*</span> x2[i]</span>
<span id="cb176-9"><a href="cha-mcmc.html#cb176-9" tabindex="-1"></a>    Y[i] <span class="sc">~</span> <span class="fu">dnorm</span>(Ypred[i], <span class="at">sd =</span> sigma)</span>
<span id="cb176-10"><a href="cha-mcmc.html#cb176-10" tabindex="-1"></a>  }</span>
<span id="cb176-11"><a href="cha-mcmc.html#cb176-11" tabindex="-1"></a>})</span>
<span id="cb176-12"><a href="cha-mcmc.html#cb176-12" tabindex="-1"></a></span>
<span id="cb176-13"><a href="cha-mcmc.html#cb176-13" tabindex="-1"></a><span class="do">## build the model</span></span>
<span id="cb176-14"><a href="cha-mcmc.html#cb176-14" tabindex="-1"></a>RJexampleModel2 <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(code, <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">N =</span> N),</span>
<span id="cb176-15"><a href="cha-mcmc.html#cb176-15" tabindex="-1"></a>                               <span class="at">data =</span> <span class="fu">list</span>(<span class="at">Y =</span> Y, <span class="at">x1 =</span> x1, <span class="at">x2 =</span> x2), </span>
<span id="cb176-16"><a href="cha-mcmc.html#cb176-16" tabindex="-1"></a>                               <span class="at">inits =</span> <span class="fu">list</span>(<span class="at">beta0 =</span> <span class="dv">0</span>, <span class="at">beta1 =</span> <span class="dv">0</span>, <span class="at">beta2 =</span> <span class="dv">0</span>,</span>
<span id="cb176-17"><a href="cha-mcmc.html#cb176-17" tabindex="-1"></a>                                            <span class="at">sigma =</span> <span class="fu">sd</span>(Y)))</span>
<span id="cb176-18"><a href="cha-mcmc.html#cb176-18" tabindex="-1"></a></span>
<span id="cb176-19"><a href="cha-mcmc.html#cb176-19" tabindex="-1"></a>RJexampleConf2 <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(RJexampleModel2)</span></code></pre></div>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb177-1"><a href="cha-mcmc.html#cb177-1" tabindex="-1"></a><span class="do">## print NIMBLE default samplers</span></span>
<span id="cb177-2"><a href="cha-mcmc.html#cb177-2" tabindex="-1"></a>RJexampleConf2<span class="sc">$</span><span class="fu">printSamplers</span>()</span></code></pre></div>
<pre><code>## [1] conjugate_dnorm_dnorm_additive sampler: beta0
## [2] conjugate_dnorm_dnorm_linear sampler: beta1
## [3] conjugate_dnorm_dnorm_linear sampler: beta2
## [4] RW sampler: sigma</code></pre>
<p>In this case, since there are no indicator variables, we need to pass to <code>configureRJ</code> the prior inclusion probabilities for each node in <code>targetNodes</code>, by specifying either one common value or a vector of values for the argument <code>priorProb</code>. This case does not allow for a stochastic prior.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb179-1"><a href="cha-mcmc.html#cb179-1" tabindex="-1"></a><span class="fu">configureRJ</span>(<span class="at">conf =</span> RJexampleConf2,     </span>
<span id="cb179-2"><a href="cha-mcmc.html#cb179-2" tabindex="-1"></a>            <span class="at">targetNodes =</span> <span class="fu">c</span>(<span class="st">&quot;beta1&quot;</span>, <span class="st">&quot;beta2&quot;</span>),</span>
<span id="cb179-3"><a href="cha-mcmc.html#cb179-3" tabindex="-1"></a>            <span class="at">priorProb =</span> <span class="fl">0.5</span>,</span>
<span id="cb179-4"><a href="cha-mcmc.html#cb179-4" tabindex="-1"></a>            <span class="at">control =</span> <span class="fu">list</span>(<span class="at">mean =</span> <span class="dv">0</span>, <span class="at">scale =</span> <span class="dv">2</span>, <span class="at">fixedValue =</span> <span class="fu">c</span>(<span class="fl">1.5</span>, <span class="dv">0</span>)))</span></code></pre></div>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="cha-mcmc.html#cb180-1" tabindex="-1"></a><span class="do">## print samplers after configureRJ</span></span>
<span id="cb180-2"><a href="cha-mcmc.html#cb180-2" tabindex="-1"></a>RJexampleConf2<span class="sc">$</span><span class="fu">printSamplers</span>()</span></code></pre></div>
<pre><code>## [1] conjugate_dnorm_dnorm_additive sampler: beta0
## [2] RW sampler: sigma
## [3] RJ_fixed_prior sampler: beta1,  priorProb: 0.5,  mean: 0,  scale: 2,  fixedValue: 1.5
## [4] RJ_toggled sampler: beta1,  samplerType: conjugate_dnorm_dnorm_linear,  fixedValue: 1.5
## [5] RJ_fixed_prior sampler: beta2,  priorProb: 0.5,  mean: 0,  scale: 2,  fixedValue: 0
## [6] RJ_toggled sampler: beta2,  samplerType: conjugate_dnorm_dnorm_linear,  fixedValue: 0</code></pre>
<p>Since there are no indicator variables, the <code>RJ_fixed_prior</code> sampler is assigned directly to each of <code>beta[1]</code> and <code>beta[2]</code> along with the <code>RJ_toggled</code> sampler. The former sets a coefficient to its <code>fixedValue</code> when it is out of the model. The latter invokes the regular sampler for the coefficient only if it is in the model at a given iteration.</p>
<p>If <code>fixedValue</code> is given when using <code>indicatorNodes</code> the values provided in <code>fixedValue</code> are ignored. However the same behavior can be obtained in this situation, using a different model specification. For example, the model in <a href="cha-mcmc.html#sec:rjmcmc-indicator">7.10.1</a> can be modified to have <code>beta1</code> equal to <span class="math inline">\(1.5\)</span> when not in the model as follows:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb182-1"><a href="cha-mcmc.html#cb182-1" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) {</span>
<span id="cb182-2"><a href="cha-mcmc.html#cb182-2" tabindex="-1"></a>    Ypred[i] <span class="ot">&lt;-</span> beta0 <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">-</span> z1) <span class="sc">*</span> <span class="fl">1.5</span> <span class="sc">*</span> beta1 <span class="sc">*</span> x1[i] <span class="sc">+</span></span>
<span id="cb182-3"><a href="cha-mcmc.html#cb182-3" tabindex="-1"></a>                z1 <span class="sc">*</span> beta1 <span class="sc">*</span> x1[i] <span class="sc">+</span> beta2 <span class="sc">*</span> z2 <span class="sc">*</span> x2[i]</span>
<span id="cb182-4"><a href="cha-mcmc.html#cb182-4" tabindex="-1"></a>    Y[i] <span class="sc">~</span> <span class="fu">dnorm</span>(Ypred[i], <span class="at">sd =</span> sigma)</span>
<span id="cb182-5"><a href="cha-mcmc.html#cb182-5" tabindex="-1"></a>  }</span></code></pre></div>
</div>
</div>
<div id="sec:samplers-provided" class="section level2 hasAnchor" number="7.11">
<h2><span class="header-section-number">7.11</span> Samplers provided with NIMBLE<a href="cha-mcmc.html#sec:samplers-provided" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Most documentation of MCMC samplers provided with NIMBLE can be found by invoking <code>help(samplers)</code> in R. Here we provide additional explanation of conjugate samplers and how complete customization can be achieved by making a sampler use an arbitrary log-likelihood function, such as to build a particle MCMC algorithm.</p>
<div id="conjugate-gibbs-samplers" class="section level3 hasAnchor" number="7.11.1">
<h3><span class="header-section-number">7.11.1</span> Conjugate (‘Gibbs’) samplers<a href="cha-mcmc.html#conjugate-gibbs-samplers" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>By default, <code>configureMCMC()</code> and <code>buildMCMC()</code> will assign conjugate samplers to all nodes satisfying a conjugate relationship, unless the option <code>useConjugacy = FALSE</code> is specified.</p>
<p>The current release of NIMBLE supports conjugate sampling of the relationships listed in Table <a href="cha-mcmc.html#tab:conjugacy">7.1</a><a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>.</p>
<table>
<caption><span id="tab:conjugacy">Table 7.1: </span> Conjugate relationships supported by NIMBLE’s MCMC engine.</caption>
<thead>
<tr class="header">
<th>Prior Distribution</th>
<th>Sampling (Dependent Node) Distribution</th>
<th align="left">Parameter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Beta</td>
<td>Bernoulli</td>
<td align="left"><code>prob</code></td>
</tr>
<tr class="even">
<td></td>
<td>Binomial</td>
<td align="left"><code>prob</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Negative Binomial</td>
<td align="left"><code>prob</code></td>
</tr>
<tr class="even">
<td>Dirichlet</td>
<td>Multinomial</td>
<td align="left"><code>prob</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Categorical</td>
<td align="left"><code>prob</code></td>
</tr>
<tr class="even">
<td>Flat</td>
<td>Normal</td>
<td align="left"><code>mean</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Lognormal</td>
<td align="left"><code>meanlog</code></td>
</tr>
<tr class="even">
<td>Gamma</td>
<td>Poisson</td>
<td align="left"><code>lambda</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Normal</td>
<td align="left"><code>tau</code></td>
</tr>
<tr class="even">
<td></td>
<td>Lognormal</td>
<td align="left"><code>taulog</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Gamma</td>
<td align="left"><code>rate</code></td>
</tr>
<tr class="even">
<td></td>
<td>Inverse Gamma</td>
<td align="left"><code>scale</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Exponential</td>
<td align="left"><code>rate</code></td>
</tr>
<tr class="even">
<td></td>
<td>Double Exponential</td>
<td align="left"><code>rate</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Weibull</td>
<td align="left"><code>lambda</code></td>
</tr>
<tr class="even">
<td>Halfflat</td>
<td>Normal</td>
<td align="left"><code>sd</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Lognormal</td>
<td align="left"><code>sdlog</code></td>
</tr>
<tr class="even">
<td>Inverse Gamma</td>
<td>Normal</td>
<td align="left"><code>var</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Lognormal</td>
<td align="left"><code>varlog</code></td>
</tr>
<tr class="even">
<td></td>
<td>Gamma</td>
<td align="left"><code>scale</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Inverse Gamma</td>
<td align="left"><code>rate</code></td>
</tr>
<tr class="even">
<td></td>
<td>Exponential</td>
<td align="left"><code>scale</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Double Exponential</td>
<td align="left"><code>scale</code></td>
</tr>
<tr class="even">
<td>Normal</td>
<td>Normal</td>
<td align="left"><code>mean</code></td>
</tr>
<tr class="odd">
<td></td>
<td>Lognormal</td>
<td align="left"><code>meanlog</code></td>
</tr>
<tr class="even">
<td>Multivariate Normal</td>
<td>Multivariate Normal</td>
<td align="left"><code>mean</code></td>
</tr>
<tr class="odd">
<td>Wishart</td>
<td>Multivariate Normal</td>
<td align="left"><code>prec</code></td>
</tr>
<tr class="even">
<td>Inverse Wishart</td>
<td>Multivariate Normal</td>
<td align="left"><code>cov</code></td>
</tr>
</tbody>
</table>
<p>Conjugate sampler functions may (optionally) dynamically check that their own posterior likelihood calculations are correct. If incorrect, a warning is issued. However, this functionality will roughly double the run-time required for conjugate sampling. By default, this option is disabled in NIMBLE. This option may be enabled with
<code>nimbleOptions(verifyConjugatePosteriors = TRUE)</code>.</p>
<p>If one wants information about conjugate node relationships for other purposes, they can be obtained using the <code>checkConjugacy</code> method on a model. This returns a named list describing all conjugate relationships. The <code>checkConjugacy</code> method can also accept a character vector argument specifying a subset of node names to check for conjugacy.
<!---  ### `binary (Gibbs) sampler` --></p>
<!---  The `binary` sampler performs Gibbs sampling for binary-valued nodes (strictly taking values 0 or 1).  This can only be used for nodes following either a `dbern(p)` or `dbinom(p, size=1)` distribution.  The `binary` sampler accepts no control list arguments. -->
<!---  ### `RW_multinomial sampler` -->
<!---  The `RW_multinomial` sampler operates exclusively on nodes following a multinomial distribution.  The sampler performs a series of Metropolis-Hastings steps between pairs of groups.  Proposals are generated via a draw from a binomial distribution, whereafter the proposed number density is moved from one group to another group.  The acceptance or rejection of these proposals follows a standard Metropolis-Hastings procedure.  Probabilities for the random binomial proposals are adapted to a target acceptance rate of 0.5. -->
<!---  The `RW_multinomial` sampler can be customized using `control` list arguments to set the adaptive properties of the sampler.  See `help(samplers)` for details.  -->
<!---  ### `RW_dirichlet sampler` -->
<!---  The `RW_dirichlet` sampler operates exclusively on nodes following a Dirichlet distribution, and is designed for the non-conjugate Dirichlet case.  The sampler performs independent adaptive Metropolis-Hastings updates on a reparameterization of the target distribution, expressed in terms of component univariate gamma distributions. -->
<!---  The `RW_dirichlet` sampler can be customized using `control` list arguments to set the adaptive properties of the sampler.  See `help(samplers)` for details. -->
<!---  ### Scalar Metropolis-Hastings random walk `RW sampler` -->
<!---  The `RW` sampler executes adaptive Metropolis-Hastings sampling with a normal proposal distribution, implementing the adaptation routine given in @Shaby2011.  This sampler can be applied to any scalar continuous-valued stochastic node, and can optionally sample on a log scale. -->
<!---  The `RW` sampler can be customized using the `control` list argument to set the initial proposal distribution scale, the adaptive properties of the sampler, the reflective property of proposals, and whether to sample on a log scale.  See `help(samplers)` for details.  -->
<!---  Note that because we use a simple normal proposal distribution on all nodes, negative proposals may be simulated for non-negative random variables. These will be rejected, so the only downsides to this are some inefficiency and the presence of warnings during uncompiled (but not compiled) execution indicating `NA` or `NaN` values.  This can be avoided in some cases by using the option `reflective = TRUE`, which reflects proposal values to stay within the range of the target node distribution. -->
<!---  ### Multivariate Metropolis-Hastings `RW_block sampler` -->
<!---  The `RW_block` sampler performs a simultaneous update of one or more model nodes, using an adaptive Metropolis-Hastings algorithm with a multivariate normal proposal distribution [@Roberts_Sahu_1997], implementing the adaptation routine given in @Shaby2011.  This sampler may be applied to any set of continuous-valued model nodes, to any single continuous-valued multivariate model node, or to any combination thereof.  -->
<!---  The `RW_block` sampler can be customized using the `control` list argument to set the initial proposal covariance, and the adaptive properties of the sampler.  See `help(samplers)` for details.  -->
<!---  ### `slice sampler` -->
<!---  The `slice` sampler performs slice sampling of the scalar node to which it is applied [@Neal2003].  This sampler can operate on either continuous-valued or discrete-valued scalar nodes.  The slice sampler performs a 'stepping out' procedure, in which the slice is iteratively expanded to the left or right by an amount `sliceWidth`.  This sampler is optionally adaptive, whereby the value of `sliceWidth` is adapted towards the observed absolute difference between successive samples. -->
<!---  The `slice` sampler can be customized using the `control` list argument to set the initial slice width, and the adaptive properties of the sampler.  See `help(samplers)` for details.  -->
<!---  ### Elliptical slice sampling: `ess sampler` -->
<!---  The `ess` sampler performs elliptical slice sampling of a single node, which must follow a multivariate normal distribution [@2010arXiv1001.0175M].  The algorithm is an extension of slice sampling [@Neal2003], generalized to the multivariate normal context.  An auxiliary variable is used to identify points on an ellipse (which passes through the current node value) as candidate samples, which are accepted contingent upon a likelihood evaluation at that point.  This algorithm requires no tuning parameters and therefore no period of adaptation, and may result in very efficient sampling from multivariate Gaussian distributions. -->
<!---  The `ess` sampler accepts no control list arguments.  See `help(samplers)` for details. -->
<!---  ### Hierarchical `crossLevel sampler` -->
<!---  This sampler is constructed to perform simultaneous updates across two levels of stochastic dependence in the model structure.  This is possible when all stochastic descendants of node(s) at one level have conjugate relationships with their own stochastic descendants.  In this situation, a Metropolis-Hastings algorithm may be used, in which a multivariate normal proposal distribution is used for the higher-level nodes, and the corresponding proposals for the lower-level nodes undergo Gibbs (conjugate) sampling.  The joint proposal is either accepted or rejected for all nodes involved based upon the Metropolis-Hastings ratio. -->
<!---  The `crossLevel` sampler can be customized using the `control` list argument to set the initial proposal covariance and the adaptive properties for the Metropolis-Hastings sampling of the higher-level nodes.  See `help(samplers)` for details.  -->
<!---  The requirement that all stochastic descendants of the `target` nodes must themselves have only conjugate descendants will be checked when the MCMC algorithm is built.  This sampler is useful when there is strong dependence across the levels of a model that causes problems with convergence or mixing. -->
</div>
<div id="subsec:HMC" class="section level3 hasAnchor" number="7.11.2">
<h3><span class="header-section-number">7.11.2</span> Hamiltonian Monte Carlo (HMC)<a href="cha-mcmc.html#subsec:HMC" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>As of version 1.0.0, NIMBLE provides support for automatic differentiation (AD), as described in Chapter <a href="cha-AD.html#cha-AD">16</a>. AD is needed for Hamiltonian Monte Carlo (HMC) sampling. The HMC algorithm is provided through the <code>nimbleHMC</code> package, which requires version 1.0.0 (or higher) of the <code>nimble</code> package.</p>
<p>HMC is an MCMC sampling algorithm that works by a physical analogy of frictionless motion on a surface that is the negative log posterior density. HMC often achieves good mixing, although at high computational cost. HMC sampling can operate on any continuous-valued model dimensions, including multiple dimensions simultaneously. HMC sampling is more flexibly applicable using <code>nimbleHMC</code> than in other implementations, since HMC can be applied to some parts of a model while other samplers are used on other (potentially overlapping) parts of the same model. Indeed, <span class="citation">R. M. Neal (<a href="references.html#ref-neal-11">2011</a>)</span> discusses this mixed application of HMC with other sampling methods.</p>
<p>The <code>nimbleHMC</code> package provides two distinct HMC samplers, which implement two versions of No-U-Turn (NUTS) HMC sampling. HMC-NUTS sampling is a self-tuning version of standard HMC, which self-tunes the step-size and the number of integration steps used in the numeric integrator’s exploration of parameter space. The <code>NUTS_classic</code> sampler in <code>nimbleHMC</code> implements the original (“classic”) HMC-NUTS algorithm developed in <span class="citation">Hoffman and Gelman (<a href="references.html#ref-hoffman2014no">2014</a>)</span>, which was the seminal version of HMC-NUTS. The <code>NUTS</code> sampler in <code>nimbleHMC</code> is a modern version of HMC-NUTS sampling with improved adaptation routines and convergence criteria, which matches the HMC sampler available in version 2.32.2 of Stan <span class="citation">(<a href="references.html#ref-stan2023stan">Stan Development Team 2023</a>)</span>.</p>
<p>The samplers provided in <code>nimbleHMC</code> can be used in <code>nimble</code>’s general MCMC system, and may be used in combination with other samplers provided with <code>nimble</code> operating on different (or overlapping) parts of the model. For convenience, <code>nimbleHMC</code> provides several different ways to set up and run HMC which allow different degrees of control:</p>
<ul>
<li><code>nimbleHMC</code> is analogous to <code>nimbleMCMC</code>: It accpets model <code>code</code>, <code>data</code>, <code>inits</code> and <code>constants</code> arguments, and performs all steps from building the model to running one or more MCMC chains. Use the <code>nimbleHMC</code> function if you want one call to apply <code>NUTS</code> sampling to all continuous-valued model dimensions, and <code>nimble</code>’s default samplers for all discrete-valued dimensions.</li>
<li><code>buildHMC</code> is analogous to <code>buildMCMC</code>: It accepts a model object as an argument, and builds an MCMC algorithm which applies <code>NUTS</code> sampling to all continuous-valued model dimensions, and <code>nimble</code>’s default samplers for all discrete-valued dimensions. Use <code>buildHMC</code> if you have created a model object, and want to automatically build the default HMC algorithm for your model.</li>
<li><code>configureHMC</code> is analogous to <code>configureMCMC</code>: It accepts a model object as an argument, and sets up a default MCMC configuration containing one <code>NUTS</code> sampler operating on all continuous-valued model dimensions, and <code>nimble</code>’s default samplers for all discrete-valued dimensions. You can also specify which <code>nodes</code> should have samplers assigned. You can then modify the MCMC configuration (use <code>addSampler</code> and other methods) to further customize it before building and running the MCMC. Use <code>configureHMC</code> if you are familiar with MCMC configuration objects, and may want to further customize your MCMC using HMC or other samplers or monitors before building the MCMC.</li>
<li><code>addHMC</code> manages use of <code>addSampler</code> to specifically add an HMC sampler for a chosen set of nodes to an exisiting MCMC configuration. It optionally removes other samplers operating on the specified nodes. Use <code>addHMC</code> to add an HMC sampler operating one or more target nodes to an exisiting MCMC configuration object.</li>
<li>For the most fine-grained control, you can use the <code>addSampler</code> method speciying the the argument <code>type="NUTS"</code> or <code>type="NUTS_classic"</code> to add HMC sampler(s) to an MCMC configuration object.</li>
</ul>
<p>As of version 1.1.0, we now support the following new functionality for AD in models:</p>
<ul>
<li>Dynamic indexing is supported, although of course one cannot take derivatives with respect to the actual index values, since they are discrete. This means the index values cannot be sampled by HMC.</li>
<li>One can take derivatives with respect to nodes assigned CAR priors, so HMC sampling can be performed on variables assigned a CAR prior(i.e., <code>dcar_normal</code> and <code>dcar_proper</code>).</li>
<li>One can take derivatives with respect to the parameters of <code>dcat</code>, <code>dconstraint</code>, and <code>dinterval</code>. Hence HMC sampling is supported for <em>parameters</em> of nodes that have <code>dcat</code>, <code>dconstraint</code>, and <code>dinterval</code> dependencies. (However, the nodes that follow one of these distributions are discrete, so derivatives with respect to those nodes themselves are not supported, and HMC cannot sample those nodes.)</li>
<li>Truncated distributions can be used, but one cannot take derivatives with respect to their parameters or the nodes themselves. This means that HMC sampling <strong>cannot</strong> be performed on nodes that have truncated nodes as dependencies.</li>
</ul>
<p>More information is available from the help pages, e.g. <code>help(nimbleHMC)</code>, <code>help(buildHMC)</code>, <code>help(configureHMC)</code>, or <code>help(addHMC)</code>.</p>
<div id="subsec:HMC-example" class="section level4 hasAnchor" number="7.11.2.1">
<h4><span class="header-section-number">7.11.2.1</span> HMC example<a href="cha-mcmc.html#subsec:HMC-example" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Here we will configure and build an MCMC to use the <code>NUTS</code> HMC sampler on a GLMM example. In this case we’ll use HMC sampling for the whole model, i.e., all parameters and latent states.</p>
<p>We’ll use a Poisson Generalized Linear Mixed Model (GLMM) as a simple example model for HMC (and also for Laplace approximation in <a href="cha-AD.html#sec:use-derivs">16.1</a>). There will be 10 groups (indexed by <code>i</code>) of 5 observations (indexed by <code>j</code>) each. Each observation has a covariate, <code>X</code>, and each group has a random effect <code>ran_eff</code>. Here is the model code:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="cha-mcmc.html#cb183-1" tabindex="-1"></a>model_code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb183-2"><a href="cha-mcmc.html#cb183-2" tabindex="-1"></a>  <span class="co"># priors </span></span>
<span id="cb183-3"><a href="cha-mcmc.html#cb183-3" tabindex="-1"></a>  intercept <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb183-4"><a href="cha-mcmc.html#cb183-4" tabindex="-1"></a>  beta <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">100</span>)</span>
<span id="cb183-5"><a href="cha-mcmc.html#cb183-5" tabindex="-1"></a>  sigma <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>, <span class="dv">10</span>)</span>
<span id="cb183-6"><a href="cha-mcmc.html#cb183-6" tabindex="-1"></a>  <span class="co"># random effects and data  </span></span>
<span id="cb183-7"><a href="cha-mcmc.html#cb183-7" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>) {</span>
<span id="cb183-8"><a href="cha-mcmc.html#cb183-8" tabindex="-1"></a>    <span class="co"># random effects</span></span>
<span id="cb183-9"><a href="cha-mcmc.html#cb183-9" tabindex="-1"></a>    ran_eff[i] <span class="sc">~</span> <span class="fu">dnorm</span>(<span class="dv">0</span>, <span class="at">sd =</span> sigma)</span>
<span id="cb183-10"><a href="cha-mcmc.html#cb183-10" tabindex="-1"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>) {</span>
<span id="cb183-11"><a href="cha-mcmc.html#cb183-11" tabindex="-1"></a>      <span class="co"># data</span></span>
<span id="cb183-12"><a href="cha-mcmc.html#cb183-12" tabindex="-1"></a>      y[i,j] <span class="sc">~</span> <span class="fu">dpois</span>(<span class="fu">exp</span>(intercept <span class="sc">+</span> beta<span class="sc">*</span>X[i,j] <span class="sc">+</span> ran_eff[i]))</span>
<span id="cb183-13"><a href="cha-mcmc.html#cb183-13" tabindex="-1"></a>    }</span>
<span id="cb183-14"><a href="cha-mcmc.html#cb183-14" tabindex="-1"></a>  }</span>
<span id="cb183-15"><a href="cha-mcmc.html#cb183-15" tabindex="-1"></a>})</span></code></pre></div>
<p>We’ll simulate some values for <code>X</code>.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb184-1"><a href="cha-mcmc.html#cb184-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb184-2"><a href="cha-mcmc.html#cb184-2" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(<span class="dv">50</span>), <span class="at">nrow =</span> <span class="dv">10</span>)</span></code></pre></div>
<p>In order to allow an algorithm to use AD for a specific model, that model must be created with <code>buildDerivs = TRUE</code>. (Note that if you use the one-step method <code>nimbleHMC</code> described above, then you do not need to build the model yourself and so you do not need to provide this <code>buildDerivs</code> option.)</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="cha-mcmc.html#cb185-1" tabindex="-1"></a>inits <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">intercept =</span> <span class="dv">0</span>, <span class="at">beta =</span> <span class="fl">0.2</span>, <span class="at">sigma =</span> <span class="fl">0.5</span>)</span>
<span id="cb185-2"><a href="cha-mcmc.html#cb185-2" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(model_code, <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">X =</span> X), <span class="at">inits =</span> inits,</span>
<span id="cb185-3"><a href="cha-mcmc.html#cb185-3" tabindex="-1"></a>      <span class="at">calculate =</span> <span class="cn">FALSE</span>, <span class="at">buildDerivs =</span> <span class="cn">TRUE</span>) <span class="co"># Here is the argument needed for AD.</span></span></code></pre></div>
<p>To finish setting up the example we need to put data values into the model. We could have provided data in the call to <code>nimbleModel</code>, but instead we will simulate them using the model itself. Specifically, we will set parameter values, simulate data values, and then set those as the data to use.</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb186-1"><a href="cha-mcmc.html#cb186-1" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">calculate</span>() <span class="co"># This will return NA because the model is not fully initialized.</span></span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<div class="sourceCode" id="cb188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb188-1"><a href="cha-mcmc.html#cb188-1" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">simulate</span>(model<span class="sc">$</span><span class="fu">getDependencies</span>(<span class="st">&#39;ran_eff&#39;</span>))</span>
<span id="cb188-2"><a href="cha-mcmc.html#cb188-2" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">calculate</span>() <span class="co"># Now the model is fully initialized: all nodes have valid values.</span></span></code></pre></div>
<pre><code>## [1] -80.74344</code></pre>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="cha-mcmc.html#cb190-1" tabindex="-1"></a>model<span class="sc">$</span><span class="fu">setData</span>(<span class="st">&#39;y&#39;</span>) <span class="co"># Now the model has y marked as data, with values from simulation.</span></span></code></pre></div>
<p>Finally, we will make a compiled version of the model.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb191-1"><a href="cha-mcmc.html#cb191-1" tabindex="-1"></a>Cmodel <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(model)</span></code></pre></div>
<p>Now we will build an HMC algorithm for the parameters and random effects in the model.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="cha-mcmc.html#cb192-1" tabindex="-1"></a><span class="fu">library</span>(nimbleHMC)</span>
<span id="cb192-2"><a href="cha-mcmc.html#cb192-2" tabindex="-1"></a>HMC <span class="ot">&lt;-</span> <span class="fu">buildHMC</span>(model)</span></code></pre></div>
<pre><code>## ===== Monitors =====
## thin = 1: beta, intercept, sigma
## ===== Samplers =====
## NUTS sampler (1)
##   - intercept, beta, sigma, ran_eff[1], ran_eff[2], ran_eff[3], ran_eff[4], ran_eff[5], ran_eff[6], ran_eff[7], ran_eff[8], ran_eff[9], ran_eff[10]</code></pre>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="cha-mcmc.html#cb194-1" tabindex="-1"></a>CHMC <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(HMC, <span class="at">project =</span> model)</span>
<span id="cb194-2"><a href="cha-mcmc.html#cb194-2" tabindex="-1"></a><span class="co"># The compiled HMC will use the compiled model.</span></span>
<span id="cb194-3"><a href="cha-mcmc.html#cb194-3" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(CHMC, <span class="at">niter =</span> <span class="dv">1000</span>, <span class="at">nburnin =</span> <span class="dv">500</span>) <span class="co"># short run for illustration</span></span></code></pre></div>
<pre><code>##   [Note] NUTS sampler (nodes: intercept, beta, sigma, ran_eff[1], ran_eff[2], ran_eff[3], ran_eff[4], ran_eff[5], ran_eff[6], r...) is using 500 warmup iterations.
##          Since `warmupMode` is &#39;default&#39; and `nburnin` &gt; 0,
##          the number of warmup iterations is equal to `nburnin`.
##          The burnin samples will be discarded, and all samples returned will be post-warmup.</code></pre>
<p>We will not investigate results in detail, but here is a summary to see that reasonable results were generated.</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb196-1"><a href="cha-mcmc.html#cb196-1" tabindex="-1"></a><span class="fu">summary</span>(coda<span class="sc">::</span><span class="fu">as.mcmc</span>(samples))</span></code></pre></div>
<pre><code>## 
## Iterations = 1:500
## Thinning interval = 1 
## Number of chains = 1 
## Sample size per chain = 500 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##              Mean     SD Naive SE Time-series SE
## beta       0.1790 0.1438 0.006432       0.008174
## intercept -0.2524 0.4463 0.019960       0.056677
## sigma      0.7912 0.4091 0.018296       0.051351
## 
## 2. Quantiles for each variable:
## 
##              2.5%      25%     50%       75%  97.5%
## beta      -0.1299  0.08311  0.1873  0.280133 0.4415
## intercept -1.6013 -0.42914 -0.1681 -0.002989 0.3520
## sigma      0.2935  0.53669  0.6886  0.943581 2.0846</code></pre>
</div>
<div id="automatic-parameter-transformation" class="section level4 hasAnchor" number="7.11.2.2">
<h4><span class="header-section-number">7.11.2.2</span> Automatic parameter transformation<a href="cha-mcmc.html#automatic-parameter-transformation" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>In the example above, <code>sigma</code> is a parameter that must be non-negative. HMC works only on unconstrained parameter spaces. NIMBLE’s HMC functionality automatically transforms any constrained parameters to be in an unconstrained parameter space, runs the MCMC, and back-transforms to the original space before providing the MCMC samples. The details of the parameter transformation system can be found in Section <a href="cha-AD.html#sec:parameter-transform">16.8</a>.</p>
</div>
</div>
<div id="particle-filter-samplers" class="section level3 hasAnchor" number="7.11.3">
<h3><span class="header-section-number">7.11.3</span> Particle filter samplers<a href="cha-mcmc.html#particle-filter-samplers" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The <code>nimbleSMC</code> package provides samplers that perform particle MCMC, primarily intended for sampling top-level parameters in state-space or hidden Markov models of time-series data. This sampler is described in Section <a href="cha-algos-provided.html#sec:particle-mcmc">8.1.2</a>.</p>
</div>
<div id="customized-log-likelihood-evaluations-rw_llfunction-sampler" class="section level3 hasAnchor" number="7.11.4">
<h3><span class="header-section-number">7.11.4</span> Customized log-likelihood evaluations: <em>RW_llFunction sampler</em><a href="cha-mcmc.html#customized-log-likelihood-evaluations-rw_llfunction-sampler" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Sometimes it is useful to control the log-likelihood calculations used for an MCMC updater instead of simply using the model. For example, one could use a sampler with a log-likelihood that analytically (or numerically) integrates over latent model nodes. Or one could use a sampler with a log-likelihood that comes from a stochastic approximation such as a particle filter (see below), allowing composition of a particle MCMC (PMCMC) algorithm <span class="citation">(<a href="references.html#ref-Andrieu_Doucet_Holenstein_2010">Andrieu, Doucet, and Holenstein 2010</a>)</span>. The <code>RW_llFunction</code> sampler handles this by using a Metropolis-Hastings algorithm with a normal proposal distribution and a user-provided log-likelihood function. To allow compiled execution, the log-likelihood function must be provided as a specialized instance of a nimbleFunction. The log-likelihood function may use the same model as the MCMC as a setup argument (as does the example below), but if so the state of the model should be unchanged during execution of the function (or you must understand the implications otherwise).</p>
<p>The <code>RW_llFunction</code> sampler can be customized using the <code>control</code> list argument to set the initial proposal distribution scale and the adaptive properties for the Metropolis-Hastings sampling. In addition, the <code>control</code> list argument must contain a named <code>llFunction</code> element. This is the specialized nimbleFunction that calculates the log-likelihood; it must accept no arguments and return a scalar double number. The return value must be the total log-likelihood of all stochastic dependents of the <code>target</code> nodes – and, if <code>includesTarget = TRUE</code>, of the target node(s) themselves – or whatever surrogate is being used for the total log-likelihood. This is a required <code>control</code> list element with no default. See <code>help(samplers)</code> for details.</p>
<p>Here is a complete example:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb198-1"><a href="cha-mcmc.html#cb198-1" tabindex="-1"></a>code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb198-2"><a href="cha-mcmc.html#cb198-2" tabindex="-1"></a>    p <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb198-3"><a href="cha-mcmc.html#cb198-3" tabindex="-1"></a>    y <span class="sc">~</span> <span class="fu">dbin</span>(p, n)</span>
<span id="cb198-4"><a href="cha-mcmc.html#cb198-4" tabindex="-1"></a>})</span>
<span id="cb198-5"><a href="cha-mcmc.html#cb198-5" tabindex="-1"></a></span>
<span id="cb198-6"><a href="cha-mcmc.html#cb198-6" tabindex="-1"></a>Rmodel <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(code, <span class="at">data =</span> <span class="fu">list</span>(<span class="at">y=</span><span class="dv">3</span>), <span class="at">inits =</span> <span class="fu">list</span>(<span class="at">p=</span><span class="fl">0.5</span>, <span class="at">n=</span><span class="dv">10</span>))</span>
<span id="cb198-7"><a href="cha-mcmc.html#cb198-7" tabindex="-1"></a></span>
<span id="cb198-8"><a href="cha-mcmc.html#cb198-8" tabindex="-1"></a>llFun <span class="ot">&lt;-</span> <span class="fu">nimbleFunction</span>(</span>
<span id="cb198-9"><a href="cha-mcmc.html#cb198-9" tabindex="-1"></a>    <span class="at">setup =</span> <span class="cf">function</span>(model) { },</span>
<span id="cb198-10"><a href="cha-mcmc.html#cb198-10" tabindex="-1"></a>    <span class="at">run =</span> <span class="cf">function</span>() {</span>
<span id="cb198-11"><a href="cha-mcmc.html#cb198-11" tabindex="-1"></a>        y <span class="ot">&lt;-</span> model<span class="sc">$</span>y</span>
<span id="cb198-12"><a href="cha-mcmc.html#cb198-12" tabindex="-1"></a>        p <span class="ot">&lt;-</span> model<span class="sc">$</span>p</span>
<span id="cb198-13"><a href="cha-mcmc.html#cb198-13" tabindex="-1"></a>        n <span class="ot">&lt;-</span> model<span class="sc">$</span>n</span>
<span id="cb198-14"><a href="cha-mcmc.html#cb198-14" tabindex="-1"></a>        ll <span class="ot">&lt;-</span> <span class="fu">lfactorial</span>(n) <span class="sc">-</span> <span class="fu">lfactorial</span>(y) <span class="sc">-</span> <span class="fu">lfactorial</span>(n<span class="sc">-</span>y) <span class="sc">+</span></span>
<span id="cb198-15"><a href="cha-mcmc.html#cb198-15" tabindex="-1"></a>              y <span class="sc">*</span> <span class="fu">log</span>(p) <span class="sc">+</span> (n<span class="sc">-</span>y) <span class="sc">*</span> <span class="fu">log</span>(<span class="dv">1</span><span class="sc">-</span>p)</span>
<span id="cb198-16"><a href="cha-mcmc.html#cb198-16" tabindex="-1"></a>        <span class="fu">returnType</span>(<span class="fu">double</span>())</span>
<span id="cb198-17"><a href="cha-mcmc.html#cb198-17" tabindex="-1"></a>        <span class="fu">return</span>(ll[<span class="dv">1</span>])</span>
<span id="cb198-18"><a href="cha-mcmc.html#cb198-18" tabindex="-1"></a>    }</span>
<span id="cb198-19"><a href="cha-mcmc.html#cb198-19" tabindex="-1"></a>)</span>
<span id="cb198-20"><a href="cha-mcmc.html#cb198-20" tabindex="-1"></a></span>
<span id="cb198-21"><a href="cha-mcmc.html#cb198-21" tabindex="-1"></a>RllFun <span class="ot">&lt;-</span> <span class="fu">llFun</span>(Rmodel)</span>
<span id="cb198-22"><a href="cha-mcmc.html#cb198-22" tabindex="-1"></a></span>
<span id="cb198-23"><a href="cha-mcmc.html#cb198-23" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">nodes =</span> <span class="cn">NULL</span>)</span>
<span id="cb198-24"><a href="cha-mcmc.html#cb198-24" tabindex="-1"></a></span>
<span id="cb198-25"><a href="cha-mcmc.html#cb198-25" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">addSampler</span>(<span class="at">target =</span> <span class="st">&quot;p&quot;</span>, <span class="at">type =</span> <span class="st">&quot;RW_llFunction&quot;</span>,</span>
<span id="cb198-26"><a href="cha-mcmc.html#cb198-26" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">list</span>(<span class="at">llFunction =</span> RllFun, <span class="at">includesTarget =</span> <span class="cn">FALSE</span>))</span>
<span id="cb198-27"><a href="cha-mcmc.html#cb198-27" tabindex="-1"></a></span>
<span id="cb198-28"><a href="cha-mcmc.html#cb198-28" tabindex="-1"></a>Rmcmc <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf)</span></code></pre></div>
<p>Note that we need to return <code>ll[1]</code> and not just <code>ll</code> because there are no scalar variables in compiled models. Hence <code>y</code> and other variables, and therefore <code>ll</code>, are of dimension 1 (i.e., vectors / one-dimensional arrays), so we need to specify the first element in order to have the return type be a scalar.</p>
<!---  ### Terminal node `posterior_predictive sampler` 
% The `posterior_predictive` sampler is only appropriate for use on terminal stochastic nodes (that is, those having no stochastic dependencies).  Note that such nodes play no role in inference but have often been included in BUGS models to accomplish posterior predictive checks.  NIMBLE allows posterior predictive values to be simulated independently of running MCMC, for example by writing a nimbleFunction to do so.  This means that in many cases where terminal stochastic nodes have been included in BUGS models, they are not needed when using NIMBLE.
The `posterior_predictive` sampler functions by calling the `simulate` method of the relevant node, then updating model probabilities and deterministic dependent nodes.  The `posterior_predictive` sampler will automatically be assigned to all terminal, non-data stochastic nodes in a model by the default MCMC configuration, so it is uncommon to manually assign this sampler.  The `posterior_predictive` sampler accepts no control list arguments. -->
</div>
</div>
<div id="sec:mcmc-example-litters" class="section level2 hasAnchor" number="7.12">
<h2><span class="header-section-number">7.12</span> Detailed MCMC example: <em>litters</em><a href="cha-mcmc.html#sec:mcmc-example-litters" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Here is a detailed example of specifying, building, compiling, and running two MCMC algorithms. We use the <code>litters</code> example from the BUGS examples.</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb199-1"><a href="cha-mcmc.html#cb199-1" tabindex="-1"></a><span class="do">###############################</span></span>
<span id="cb199-2"><a href="cha-mcmc.html#cb199-2" tabindex="-1"></a><span class="do">##### model configuration #####</span></span>
<span id="cb199-3"><a href="cha-mcmc.html#cb199-3" tabindex="-1"></a><span class="do">###############################</span></span>
<span id="cb199-4"><a href="cha-mcmc.html#cb199-4" tabindex="-1"></a></span>
<span id="cb199-5"><a href="cha-mcmc.html#cb199-5" tabindex="-1"></a><span class="co"># define our model using BUGS syntax</span></span>
<span id="cb199-6"><a href="cha-mcmc.html#cb199-6" tabindex="-1"></a>litters_code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb199-7"><a href="cha-mcmc.html#cb199-7" tabindex="-1"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>G) {</span>
<span id="cb199-8"><a href="cha-mcmc.html#cb199-8" tabindex="-1"></a>        a[i] <span class="sc">~</span> <span class="fu">dgamma</span>(<span class="dv">1</span>, .<span class="dv">001</span>)</span>
<span id="cb199-9"><a href="cha-mcmc.html#cb199-9" tabindex="-1"></a>        b[i] <span class="sc">~</span> <span class="fu">dgamma</span>(<span class="dv">1</span>, .<span class="dv">001</span>)</span>
<span id="cb199-10"><a href="cha-mcmc.html#cb199-10" tabindex="-1"></a>        <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) {</span>
<span id="cb199-11"><a href="cha-mcmc.html#cb199-11" tabindex="-1"></a>            r[i,j] <span class="sc">~</span> <span class="fu">dbin</span>(p[i,j], n[i,j])</span>
<span id="cb199-12"><a href="cha-mcmc.html#cb199-12" tabindex="-1"></a>            p[i,j] <span class="sc">~</span> <span class="fu">dbeta</span>(a[i], b[i]) </span>
<span id="cb199-13"><a href="cha-mcmc.html#cb199-13" tabindex="-1"></a>        }</span>
<span id="cb199-14"><a href="cha-mcmc.html#cb199-14" tabindex="-1"></a>        mu[i] <span class="ot">&lt;-</span> a[i] <span class="sc">/</span> (a[i] <span class="sc">+</span> b[i])</span>
<span id="cb199-15"><a href="cha-mcmc.html#cb199-15" tabindex="-1"></a>        theta[i] <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">/</span> (a[i] <span class="sc">+</span> b[i])</span>
<span id="cb199-16"><a href="cha-mcmc.html#cb199-16" tabindex="-1"></a>    }</span>
<span id="cb199-17"><a href="cha-mcmc.html#cb199-17" tabindex="-1"></a>})</span>
<span id="cb199-18"><a href="cha-mcmc.html#cb199-18" tabindex="-1"></a></span>
<span id="cb199-19"><a href="cha-mcmc.html#cb199-19" tabindex="-1"></a><span class="co"># list of fixed constants</span></span>
<span id="cb199-20"><a href="cha-mcmc.html#cb199-20" tabindex="-1"></a>constants <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">G =</span> <span class="dv">2</span>,</span>
<span id="cb199-21"><a href="cha-mcmc.html#cb199-21" tabindex="-1"></a>                  <span class="at">N =</span> <span class="dv">16</span>,</span>
<span id="cb199-22"><a href="cha-mcmc.html#cb199-22" tabindex="-1"></a>                  <span class="at">n =</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">13</span>, <span class="dv">12</span>, <span class="dv">12</span>, <span class="dv">11</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">9</span>,  <span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">11</span>, <span class="dv">8</span>, <span class="dv">10</span>, <span class="dv">13</span>,</span>
<span id="cb199-23"><a href="cha-mcmc.html#cb199-23" tabindex="-1"></a>                      <span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">10</span>,  <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">5</span>,  <span class="dv">9</span>,  <span class="dv">9</span>, <span class="dv">13</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>,  <span class="dv">6</span>, </span>
<span id="cb199-24"><a href="cha-mcmc.html#cb199-24" tabindex="-1"></a>                      <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">7</span>), <span class="at">nrow =</span> <span class="dv">2</span>))</span>
<span id="cb199-25"><a href="cha-mcmc.html#cb199-25" tabindex="-1"></a></span>
<span id="cb199-26"><a href="cha-mcmc.html#cb199-26" tabindex="-1"></a><span class="co"># list specifying model data</span></span>
<span id="cb199-27"><a href="cha-mcmc.html#cb199-27" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">r =</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">13</span>, <span class="dv">12</span>, <span class="dv">12</span>, <span class="dv">11</span>, <span class="dv">9</span>, <span class="dv">10</span>,  <span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">10</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">9</span>,</span>
<span id="cb199-28"><a href="cha-mcmc.html#cb199-28" tabindex="-1"></a>                 <span class="dv">11</span>, <span class="dv">8</span>, <span class="dv">9</span>,  <span class="dv">8</span>,  <span class="dv">9</span>,  <span class="dv">4</span>, <span class="dv">8</span>,  <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">5</span> , <span class="dv">5</span>, <span class="dv">3</span>,  <span class="dv">7</span>, <span class="dv">3</span>, </span>
<span id="cb199-29"><a href="cha-mcmc.html#cb199-29" tabindex="-1"></a>                 <span class="dv">7</span>, <span class="dv">0</span>), <span class="at">nrow =</span> <span class="dv">2</span>))</span>
<span id="cb199-30"><a href="cha-mcmc.html#cb199-30" tabindex="-1"></a></span>
<span id="cb199-31"><a href="cha-mcmc.html#cb199-31" tabindex="-1"></a><span class="co"># list specifying initial values</span></span>
<span id="cb199-32"><a href="cha-mcmc.html#cb199-32" tabindex="-1"></a>inits <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">a =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb199-33"><a href="cha-mcmc.html#cb199-33" tabindex="-1"></a>              <span class="at">b =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb199-34"><a href="cha-mcmc.html#cb199-34" tabindex="-1"></a>              <span class="at">p =</span> <span class="fu">matrix</span>(<span class="fl">0.5</span>, <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">16</span>),</span>
<span id="cb199-35"><a href="cha-mcmc.html#cb199-35" tabindex="-1"></a>              <span class="at">mu    =</span> <span class="fu">c</span>(.<span class="dv">5</span>, .<span class="dv">5</span>),</span>
<span id="cb199-36"><a href="cha-mcmc.html#cb199-36" tabindex="-1"></a>              <span class="at">theta =</span> <span class="fu">c</span>(.<span class="dv">5</span>, .<span class="dv">5</span>))</span>
<span id="cb199-37"><a href="cha-mcmc.html#cb199-37" tabindex="-1"></a></span>
<span id="cb199-38"><a href="cha-mcmc.html#cb199-38" tabindex="-1"></a><span class="co"># build the R model object</span></span>
<span id="cb199-39"><a href="cha-mcmc.html#cb199-39" tabindex="-1"></a>Rmodel <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(litters_code,</span>
<span id="cb199-40"><a href="cha-mcmc.html#cb199-40" tabindex="-1"></a>                      <span class="at">constants =</span> constants,</span>
<span id="cb199-41"><a href="cha-mcmc.html#cb199-41" tabindex="-1"></a>                      <span class="at">data      =</span> data,</span>
<span id="cb199-42"><a href="cha-mcmc.html#cb199-42" tabindex="-1"></a>                      <span class="at">inits     =</span> inits)</span>
<span id="cb199-43"><a href="cha-mcmc.html#cb199-43" tabindex="-1"></a></span>
<span id="cb199-44"><a href="cha-mcmc.html#cb199-44" tabindex="-1"></a></span>
<span id="cb199-45"><a href="cha-mcmc.html#cb199-45" tabindex="-1"></a><span class="do">###########################################</span></span>
<span id="cb199-46"><a href="cha-mcmc.html#cb199-46" tabindex="-1"></a><span class="do">##### MCMC configuration and building #####</span></span>
<span id="cb199-47"><a href="cha-mcmc.html#cb199-47" tabindex="-1"></a><span class="do">###########################################</span></span>
<span id="cb199-48"><a href="cha-mcmc.html#cb199-48" tabindex="-1"></a></span>
<span id="cb199-49"><a href="cha-mcmc.html#cb199-49" tabindex="-1"></a><span class="co"># generate the default MCMC configuration;</span></span>
<span id="cb199-50"><a href="cha-mcmc.html#cb199-50" tabindex="-1"></a><span class="co"># only wish to monitor the derived quantity &quot;mu&quot;</span></span>
<span id="cb199-51"><a href="cha-mcmc.html#cb199-51" tabindex="-1"></a>mcmcConf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel, <span class="at">monitors =</span> <span class="st">&quot;mu&quot;</span>)</span>
<span id="cb199-52"><a href="cha-mcmc.html#cb199-52" tabindex="-1"></a></span>
<span id="cb199-53"><a href="cha-mcmc.html#cb199-53" tabindex="-1"></a><span class="co"># check the samplers assigned by default MCMC configuration</span></span>
<span id="cb199-54"><a href="cha-mcmc.html#cb199-54" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printSamplers</span>()</span>
<span id="cb199-55"><a href="cha-mcmc.html#cb199-55" tabindex="-1"></a></span>
<span id="cb199-56"><a href="cha-mcmc.html#cb199-56" tabindex="-1"></a><span class="co"># double-check our monitors, and thinning interval</span></span>
<span id="cb199-57"><a href="cha-mcmc.html#cb199-57" tabindex="-1"></a>mcmcConf<span class="sc">$</span><span class="fu">printMonitors</span>()</span>
<span id="cb199-58"><a href="cha-mcmc.html#cb199-58" tabindex="-1"></a></span>
<span id="cb199-59"><a href="cha-mcmc.html#cb199-59" tabindex="-1"></a><span class="co"># build the executable R MCMC function</span></span>
<span id="cb199-60"><a href="cha-mcmc.html#cb199-60" tabindex="-1"></a>mcmc <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf)</span>
<span id="cb199-61"><a href="cha-mcmc.html#cb199-61" tabindex="-1"></a></span>
<span id="cb199-62"><a href="cha-mcmc.html#cb199-62" tabindex="-1"></a><span class="co"># let&#39;s try another MCMC, as well,</span></span>
<span id="cb199-63"><a href="cha-mcmc.html#cb199-63" tabindex="-1"></a><span class="co"># this time using the crossLevel sampler for top-level nodes</span></span>
<span id="cb199-64"><a href="cha-mcmc.html#cb199-64" tabindex="-1"></a></span>
<span id="cb199-65"><a href="cha-mcmc.html#cb199-65" tabindex="-1"></a><span class="co"># generate an empty MCMC configuration</span></span>
<span id="cb199-66"><a href="cha-mcmc.html#cb199-66" tabindex="-1"></a><span class="co"># we need a new copy of the model to avoid compilation errors</span></span>
<span id="cb199-67"><a href="cha-mcmc.html#cb199-67" tabindex="-1"></a>Rmodel2 <span class="ot">&lt;-</span> Rmodel<span class="sc">$</span><span class="fu">newModel</span>()</span>
<span id="cb199-68"><a href="cha-mcmc.html#cb199-68" tabindex="-1"></a>mcmcConf_CL <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(Rmodel2, <span class="at">nodes =</span> <span class="cn">NULL</span>, <span class="at">monitors =</span> <span class="st">&quot;mu&quot;</span>)</span>
<span id="cb199-69"><a href="cha-mcmc.html#cb199-69" tabindex="-1"></a></span>
<span id="cb199-70"><a href="cha-mcmc.html#cb199-70" tabindex="-1"></a><span class="co"># add two crossLevel samplers</span></span>
<span id="cb199-71"><a href="cha-mcmc.html#cb199-71" tabindex="-1"></a>mcmcConf_CL<span class="sc">$</span><span class="fu">addSampler</span>(<span class="at">target =</span> <span class="fu">c</span>(<span class="st">&quot;a[1]&quot;</span>, <span class="st">&quot;b[1]&quot;</span>), <span class="at">type =</span> <span class="st">&quot;crossLevel&quot;</span>)</span>
<span id="cb199-72"><a href="cha-mcmc.html#cb199-72" tabindex="-1"></a>mcmcConf_CL<span class="sc">$</span><span class="fu">addSampler</span>(<span class="at">target =</span> <span class="fu">c</span>(<span class="st">&quot;a[2]&quot;</span>, <span class="st">&quot;b[2]&quot;</span>), <span class="at">type =</span> <span class="st">&quot;crossLevel&quot;</span>)</span>
<span id="cb199-73"><a href="cha-mcmc.html#cb199-73" tabindex="-1"></a></span>
<span id="cb199-74"><a href="cha-mcmc.html#cb199-74" tabindex="-1"></a><span class="co"># let&#39;s check the samplers</span></span>
<span id="cb199-75"><a href="cha-mcmc.html#cb199-75" tabindex="-1"></a>mcmcConf_CL<span class="sc">$</span><span class="fu">printSamplers</span>()</span>
<span id="cb199-76"><a href="cha-mcmc.html#cb199-76" tabindex="-1"></a></span>
<span id="cb199-77"><a href="cha-mcmc.html#cb199-77" tabindex="-1"></a><span class="co"># build this second executable R MCMC function</span></span>
<span id="cb199-78"><a href="cha-mcmc.html#cb199-78" tabindex="-1"></a>mcmc_CL <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(mcmcConf_CL)</span>
<span id="cb199-79"><a href="cha-mcmc.html#cb199-79" tabindex="-1"></a></span>
<span id="cb199-80"><a href="cha-mcmc.html#cb199-80" tabindex="-1"></a></span>
<span id="cb199-81"><a href="cha-mcmc.html#cb199-81" tabindex="-1"></a><span class="do">###################################</span></span>
<span id="cb199-82"><a href="cha-mcmc.html#cb199-82" tabindex="-1"></a><span class="do">##### compile to C++, and run #####</span></span>
<span id="cb199-83"><a href="cha-mcmc.html#cb199-83" tabindex="-1"></a><span class="do">###################################</span></span>
<span id="cb199-84"><a href="cha-mcmc.html#cb199-84" tabindex="-1"></a></span>
<span id="cb199-85"><a href="cha-mcmc.html#cb199-85" tabindex="-1"></a><span class="co"># compile the two copies of the model</span></span>
<span id="cb199-86"><a href="cha-mcmc.html#cb199-86" tabindex="-1"></a>Cmodel <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmodel)</span>
<span id="cb199-87"><a href="cha-mcmc.html#cb199-87" tabindex="-1"></a>Cmodel2 <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(Rmodel2)</span>
<span id="cb199-88"><a href="cha-mcmc.html#cb199-88" tabindex="-1"></a></span>
<span id="cb199-89"><a href="cha-mcmc.html#cb199-89" tabindex="-1"></a><span class="co"># compile both MCMC algorithms, in the same</span></span>
<span id="cb199-90"><a href="cha-mcmc.html#cb199-90" tabindex="-1"></a><span class="co"># project as the R model object</span></span>
<span id="cb199-91"><a href="cha-mcmc.html#cb199-91" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: at this time, we recommend compiling ALL</span></span>
<span id="cb199-92"><a href="cha-mcmc.html#cb199-92" tabindex="-1"></a><span class="co"># executable MCMC functions together</span></span>
<span id="cb199-93"><a href="cha-mcmc.html#cb199-93" tabindex="-1"></a>Cmcmc <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(mcmc, <span class="at">project =</span> Rmodel)</span>
<span id="cb199-94"><a href="cha-mcmc.html#cb199-94" tabindex="-1"></a>Cmcmc_CL <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(mcmc_CL, <span class="at">project =</span> Rmodel2)</span>
<span id="cb199-95"><a href="cha-mcmc.html#cb199-95" tabindex="-1"></a></span>
<span id="cb199-96"><a href="cha-mcmc.html#cb199-96" tabindex="-1"></a><span class="co"># run the default MCMC function,</span></span>
<span id="cb199-97"><a href="cha-mcmc.html#cb199-97" tabindex="-1"></a><span class="co"># and example the mean of mu[1]</span></span>
<span id="cb199-98"><a href="cha-mcmc.html#cb199-98" tabindex="-1"></a>Cmcmc<span class="sc">$</span><span class="fu">run</span>(<span class="dv">1000</span>)</span>
<span id="cb199-99"><a href="cha-mcmc.html#cb199-99" tabindex="-1"></a>cSamplesMatrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(Cmcmc<span class="sc">$</span>mvSamples) <span class="co"># alternative: as.list</span></span>
<span id="cb199-100"><a href="cha-mcmc.html#cb199-100" tabindex="-1"></a><span class="fu">mean</span>(cSamplesMatrix[, <span class="st">&quot;mu[1]&quot;</span>])</span>
<span id="cb199-101"><a href="cha-mcmc.html#cb199-101" tabindex="-1"></a></span>
<span id="cb199-102"><a href="cha-mcmc.html#cb199-102" tabindex="-1"></a><span class="co"># run the crossLevel MCMC function,</span></span>
<span id="cb199-103"><a href="cha-mcmc.html#cb199-103" tabindex="-1"></a><span class="co"># and examine the mean of mu[1]</span></span>
<span id="cb199-104"><a href="cha-mcmc.html#cb199-104" tabindex="-1"></a>Cmcmc_CL<span class="sc">$</span><span class="fu">run</span>(<span class="dv">1000</span>)</span>
<span id="cb199-105"><a href="cha-mcmc.html#cb199-105" tabindex="-1"></a>cSamplesMatrix_CL <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(Cmcmc_CL<span class="sc">$</span>mvSamples)</span>
<span id="cb199-106"><a href="cha-mcmc.html#cb199-106" tabindex="-1"></a><span class="fu">mean</span>(cSamplesMatrix_CL[, <span class="st">&quot;mu[1]&quot;</span>])</span>
<span id="cb199-107"><a href="cha-mcmc.html#cb199-107" tabindex="-1"></a></span>
<span id="cb199-108"><a href="cha-mcmc.html#cb199-108" tabindex="-1"></a></span>
<span id="cb199-109"><a href="cha-mcmc.html#cb199-109" tabindex="-1"></a><span class="do">###################################</span></span>
<span id="cb199-110"><a href="cha-mcmc.html#cb199-110" tabindex="-1"></a><span class="do">#### run multiple MCMC chains #####</span></span>
<span id="cb199-111"><a href="cha-mcmc.html#cb199-111" tabindex="-1"></a><span class="do">###################################</span></span>
<span id="cb199-112"><a href="cha-mcmc.html#cb199-112" tabindex="-1"></a></span>
<span id="cb199-113"><a href="cha-mcmc.html#cb199-113" tabindex="-1"></a><span class="co"># run 3 chains of the crossLevel MCMC</span></span>
<span id="cb199-114"><a href="cha-mcmc.html#cb199-114" tabindex="-1"></a>samplesList <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(Cmcmc_CL, <span class="at">niter=</span><span class="dv">1000</span>, <span class="at">nchains=</span><span class="dv">3</span>)</span>
<span id="cb199-115"><a href="cha-mcmc.html#cb199-115" tabindex="-1"></a></span>
<span id="cb199-116"><a href="cha-mcmc.html#cb199-116" tabindex="-1"></a><span class="fu">lapply</span>(samplesList, dim)</span></code></pre></div>
</div>
<div id="mcmc-suite-compare-mcmcs" class="section level2 hasAnchor" number="7.13">
<h2><span class="header-section-number">7.13</span> Comparing different MCMCs with <em>MCMCsuite</em> and <em>compareMCMCs</em><a href="cha-mcmc.html#mcmc-suite-compare-mcmcs" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Please see the <code>compareMCMCs</code> package for the features previously provided by <code>MCMCsuite</code> and <code>compareMCMCs</code> in NIMBLE (until version 0.8.0). The <code>compareMCMCs</code> package provides tools to automatically run MCMC in nimble (including multiple sampler configurations), WinBUGS, OpenBUGS, JAGS, Stan, or any other engine for which you provide a simple common interface. The package makes it easy to manage comparison metrics and generate html pages with comparison figures.</p>
</div>
<div id="running-mcmc-chains-in-parallel" class="section level2 hasAnchor" number="7.14">
<h2><span class="header-section-number">7.14</span> Running MCMC chains in parallel<a href="cha-mcmc.html#running-mcmc-chains-in-parallel" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>It is possible to run multiple chains in parallel using standard R parallelization packages such as <code>parallel</code>, <code>foreach</code>, and <code>future</code>. However, you must create separate copies of all model and MCMC objects using <code>nimbleModel</code>, <code>buildMCMC</code>, <code>compileNimble</code>, etc. This is because NIMBLE uses Reference Classes and R6 classes, so copying such objects simply creates a new variable name that refers to the original object.</p>
<p>Thus, in your parallel loop or lapply-style statement, you should run <code>nimbleModel</code> and all subsequent calls to create and compile the model and MCMC algorithm within the parallelized block of code, once for each MCMC chain being run in parallel.</p>
<p>For a worked example, please see <a href="https://r-nimble.org/nimbleExamples/parallelizing_NIMBLE.html">the parallelization example on our webpage</a>.</p>

<!--- % See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr -->
</div>
</div>
<div class="footnotes">
<hr />
<ol start="18">
<li id="fn18"><p>See Section <a href="cha-data-structures.html#sec:modelValues-struct">14.1</a> for general information on modelValues.<a href="cha-mcmc.html#fnref18" class="footnote-back">↩︎</a></p></li>
<li id="fn19"><p>Prior to version 0.12.0, NIMBLE required specific monitors, because WAIC was calculated at the end of the MCMC using the entire set of MCMC samples.<a href="cha-mcmc.html#fnref19" class="footnote-back">↩︎</a></p></li>
<li id="fn20"><p>NIMBLE’s internal definitions of these relationships can be viewed with <code>nimble:::conjugacyRelationshipsInputList</code>.<a href="cha-mcmc.html#fnref20" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="cha-building-models.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="cha-algos-provided.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["NimbleUserManual.pdf", "NimbleUserManual.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
},
"toc_depth": 3
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
