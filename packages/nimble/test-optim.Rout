
R version 3.3.3 (2017-03-06) -- "Another Canoe"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source(system.file(file.path('tests', 'test_utils.R'), package = 'nimble'))
Loading required package: testthat
Loading required package: nimble

Attaching package: ‘nimble’

The following object is masked from ‘package:stats’:

    simulate

> 
> context("Testing of the optim() function in NIMBLE code")
> 
> # The method "SANN" uses the gr arg to specify a transition kernel, so we test it independently.
> methodsAllowingGradient <- c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B")
> 
> # Test helper to verify code.
> normalizeWhitespace <- function(lines) {
+     line <- paste(lines, collapse = ' ')
+     line <- gsub('\\s+', ' ', line)  # Shrink internal whitespace.
+     line <- gsub('^\\s+', '', line)  # Remove leading whitespace.
+     line <- gsub('\\s+$', '', line)  # Remove trailing whitespace.
+     return(line)
+ }
> 
> test_that("normalizeWhiteSpace() works", {
+     expect_equal(normalizeWhitespace('  a b   cde  fg hi'), 'a b cde fg hi')
+ })
> 
> test_that("nimOptim() behaves mostly like optim()", {
+     par <- c(1, 2, 3, 4)
+     fn <- function(x) { sum(x ^ 2) }
+     expected <- optim(par, fn)
+     actual <- nimOptim(par, fn)
+     # The return types differ.
+     expect_equal(class(expected), 'list')
+     expect_equal(as.character(class(actual)), 'OptimResultNimbleList')
+     # But the values mostly agree.
+     expect_equal(actual$par, expected$par)
+     expect_equal(actual$convergence, expected$convergence)
+     expect_equal(actual$value, expected$value)
+     expect_equal(actual$counts, unname(expected$counts))
+ })
> 
> test_that("nimbleFunction() replaces optim() with nimOptim()", {
+     # Note that nimCallee may be undefined, since nimCaller$run() is never called.
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     expect_equal(normalizeWhitespace(deparse(nimCaller$run@.Data)),
+                  'function (par) { return(nimOptim(par, nimCallee)) }')
+ })
> 
> test_that("nimbleFunction with optim() runs", {
+     nimCallee <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     temporarilyAssignInGlobalEnv(nimCallee)  # Work around scoping issues.
+     par <- c(1.2, 3.4)
+     nimCaller$run(par)
+ })
> 
> test_that("when an RCfunction optim()izes an RCfunction, the R and DSL behavior mostly agree", {
+     # Define R versions.
+     callee <- function(par) { return(sum(par ^ 2)) }
+     caller <- function(par) { return(optim(par, callee)) }
+     # Define DSL versions.
+     nimCallee <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimCallee)  # Work around scoping issues.
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     expected <- caller(par)
+     actual <- nimCaller(par)
+     expect_equal(actual$par, expected$par)
+     expect_equal(actual$convergence, expected$convergence)
+     expect_equal(actual$value, expected$value)
+     expect_equal(actual$counts, unname(expected$counts))
+ })
> 
> test_that("when a nimbleFunction optim()izes an RCfunction, the R and DSL behavior mostly agree", {
+     # Define R versions.
+     callee <- function(par) { return(sum(par ^ 2)) }
+     caller <- function(par) { return(optim(par, callee)) }
+     # Define DSL versions.
+     nimCallee <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     temporarilyAssignInGlobalEnv(nimCallee)  # Work around scoping issues.
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     expected <- caller(par)
+     actual <- nimCaller$run(par)
+     expect_equal(actual$par, expected$par)
+     expect_equal(actual$convergence, expected$convergence)
+     expect_equal(actual$value, expected$value)
+     expect_equal(actual$counts, unname(expected$counts))
+ })
> 
> test_that("when a nimbleFunction optim()izes an RCfunction with gradient, the R and DSL behavior mostly agree", {
+     # Define R versions.
+     fn <- function(par) { return(sum(par ^ 2)) }
+     gr <- function(par) { return(2 * par) }
+     caller <- function(par, method) {
+         return(optim(par, fn, gr, method = method))
+     }
+     # Define DSL versions.
+     nimFn <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimGr <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(2 * par)
+             returnType(double(1))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1), method = character(0)) {
+             return(optim(par, nimFn, nimGr, method = method))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     temporarilyAssignInGlobalEnv(nimFn)  # Work around scoping issues.
+     temporarilyAssignInGlobalEnv(nimGr)  # Work around scoping issues.
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     for (method in methodsAllowingGradient) {
+         info = paste(' where method =', method)
+         expected <- caller(par, method)
+         actual <- nimCaller$run(par, method)
+         expect_equal(actual$par, expected$par, info = info)
+         expect_equal(actual$convergence, expected$convergence, info = info)
+         expect_equal(actual$value, expected$value, info = info)
+         expect_equal(actual$counts, unname(expected$counts), info = info)
+     }
+     expect_error(caller(par, "bogus-method"))
+     expect_error(nimCaller$run(par, "bogus-method"))
+ })
> 
> test_that("when a nimbleFunction optim()izes a nimbleFunction, the R and DSL behavior mostly agree", {
+     # Define R versions.
+     callee <- function(par) { return(sum(par ^ 2)) }
+     caller <- function(par) { return(optim(par, callee)) }
+     # Define DSL versions.
+     nimCalleeGen <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimCalleeGen)  # Work around scoping issues.
+     nimCaller <- nimbleFunction(
+         setup = function() {
+             nimCallee <- nimCalleeGen()
+         },
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee$run))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     expected <- caller(par)
+     actual <- nimCaller$run(par)
+     expect_equal(actual$par, expected$par)
+     expect_equal(actual$convergence, expected$convergence)
+     expect_equal(actual$value, expected$value)
+     expect_equal(actual$counts, unname(expected$counts))
+ })
> 
> test_that("when an RCfunction optim()izes an RCfunction, the DSL and C++ behavior agree", {
+     nimCallee <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimCallee)  # Work around scoping issues.
+     # Test agreement.
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     par <- c(1.2, 3.4)
+     expected <- nimCaller(par)
+     actual <- compiledCaller(par)
+     expect_equal(actual, expected)
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c dynamicRegistrations_05_17_14_38_08.cpp -o dynamicRegistrations_05_17_14_38_08.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o dynamicRegistrations_05_17_14_38_08.so dynamicRegistrations_05_17_14_38_08.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_1_rcFun_11.cpp -o P_1_rcFun_11.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_1_rcFun_11_05_17_14_38_08.so P_1_rcFun_11.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
> 
> test_that("when a nimbleFunction optim()izes an RCfunction, the DSL and C++ behavior agree", {
+     nimCallee <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     temporarilyAssignInGlobalEnv(nimCallee)  # Work around scoping issues.
+     # Test agreement.
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     par <- c(1.2, 3.4)
+     expected <- nimCaller$run(par)
+     actual <- compiledCaller$run(par)
+     expect_equal(actual, expected)
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_2_nfRefClass_R_GlobalEnv94.cpp -o P_2_nfRefClass_R_GlobalEnv94.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_2_nfRefClass_R_GlobalEnv94_05_17_14_38_09.so P_2_nfRefClass_R_GlobalEnv94.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
> 
> test_that("when a nimbleFunction optim()izes a nimbleFunction, the DSL and C++ behavior agree", {
+     nimCalleeGen <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimCalleeGen)  # Work around scoping issues.
+     nimCaller <- nimbleFunction(
+         setup = function() {
+             nimCallee <- nimCalleeGen()
+         },
+         run = function(par = double(1)) {
+             return(optim(par, nimCallee$run))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     # Test agreement.
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     par <- c(1.2, 3.4)
+     expected <- nimCaller$run(par)
+     actual <- compiledCaller$run(par)
+     expect_equal(actual, expected)
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_3_nfRefClass_R_GlobalEnv96.cpp -o P_3_nfRefClass_R_GlobalEnv96.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_3_nfRefClass_R_GlobalEnv96_05_17_14_38_11.so P_3_nfRefClass_R_GlobalEnv96.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
> 
> test_that("when an RCfunction optim()izes an RCfunction with gradient, the DSL and C++ behavior mostly agree", {
+     nimFn <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimGr <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(2 * par)
+             returnType(double(1))
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimFn)  # Work around scoping issues.
+     temporarilyAssignInGlobalEnv(nimGr)  # Work around scoping issues.
+     nimCaller <- nimbleFunction(
+         run = function(par = double(1), method = character(0)) {
+             return(optim(par, nimFn, nimGr, method = method))
+             returnType(optimResultNimbleList())
+         }
+     )
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     for (method in methodsAllowingGradient) {
+         info = paste(' where method =', method)
+         expected <- nimCaller(par, method)
+         actual <- compiledCaller(par, method)
+         expect_equal(actual$par, expected$par, info = info)
+         expect_equal(actual$convergence, expected$convergence, info = info)
+         expect_equal(actual$value, expected$value, info = info)
+         expect_equal(actual$counts, unname(expected$counts), info = info)
+     }
+     expect_error(nimCaller(par, "bogus-method"))
+     expect_error(compiledCaller(par, "bogus-method"))
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_4_rcFun_15.cpp -o P_4_rcFun_15.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_4_rcFun_15_05_17_14_38_12.so P_4_rcFun_15.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
> 
> test_that("when a nimbleFunction optim()izes an RCfunction with gradient, the DSL and C++ behavior mostly agree", {
+     nimFn <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimGr <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(2 * par)
+             returnType(double(1))
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimFn)  # Work around scoping issues.
+     temporarilyAssignInGlobalEnv(nimGr)  # Work around scoping issues.
+     nimCaller <- nimbleFunction(
+         setup = TRUE,
+         run = function(par = double(1), method = character(0)) {
+             return(optim(par, nimFn, nimGr, method = method))
+             returnType(optimResultNimbleList())
+         }
+     )()
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     for (method in methodsAllowingGradient) {
+         info = paste(' where method =', method)
+         expected <- nimCaller$run(par, method)
+         actual <- compiledCaller$run(par, method)
+         expect_equal(actual$par, expected$par, info = info)
+         expect_equal(actual$convergence, expected$convergence, info = info)
+         expect_equal(actual$value, expected$value, info = info)
+         expect_equal(actual$counts, unname(expected$counts), info = info)
+     }
+     expect_error(nimCaller$run(par, "bogus-method"))
+     expect_error(compiledCaller$run(par, "bogus-method"))
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_5_nfRefClass_R_GlobalEnv97.cpp -o P_5_nfRefClass_R_GlobalEnv97.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_5_nfRefClass_R_GlobalEnv97_05_17_14_38_14.so P_5_nfRefClass_R_GlobalEnv97.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR
> 
> # FAILS, sometimes crashing rstudio
> test_that("when an RCfunction optimizes an RCfunction with SANN, the DSL and C++ behavior mostly agree", {
+     nimFn <- nimbleFunction(
+         run = function(par = double(1)) {
+             return(sum(par ^ 2))
+             returnType(double(0))
+         }
+     )
+     nimGr <- nimbleFunction(
+         run = function(par = double(1)) {
+             # Work around https://github.com/nimble-dev/nimble/issues/351
+             direction <- rnorm(length(par))
+             return(direction)
+             returnType(double(1))
+         }
+     )
+     temporarilyAssignInGlobalEnv(nimFn)  # Work around scoping issues.
+     temporarilyAssignInGlobalEnv(nimGr)  # Work around scoping issues.
+     nimCaller <- nimbleFunction(
+         run = function(par = double(1), method = character(0)) {
+             return(optim(par, nimFn, nimGr, method = method))
+             returnType(optimResultNimbleList())
+         }
+     )
+     compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)
+     # Test approximate agreement (i.e. that most fields agree).
+     par <- c(1.2, 3.4)
+     expected <- nimCaller(par, method = "SANN")
+     actual <- compiledCaller(par, method = "SANN")
+     expect_equal(actual$par, expected$par)
+     expect_equal(actual$convergence, expected$convergence)
+     expect_equal(actual$value, expected$value)
+     expect_equal(actual$counts, unname(expected$counts))
+ })
clang++ -Qunused-arguments -I/usr/share/R/include -DNDEBUG  -DEIGEN_MPL2_ONLY=1 -I"/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/include" -Wno-misleading-indentation -Wno-ignored-attributes -Wno-deprecated-declarations     -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c P_6_rcFun_20.cpp -o P_6_rcFun_20.o
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
warning: unknown warning option '-Wno-misleading-indentation'; did you mean '-Wno-missing-declarations'? [-Wunknown-warning-option]
1 warning generated.
clang++ -Qunused-arguments -shared -L/usr/lib/R/lib -Wl,-Bsymbolic-functions -Wl,-z,relro -o P_6_rcFun_20_05_17_14_38_15.so P_6_rcFun_20.o -L/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -lnimble -Wl,-rpath=/home/fritz/R/x86_64-pc-linux-gnu-library/3.3/nimble/CppCode -llapack -lblas -L/usr/lib/R/lib -lR

 *** caught segfault ***
address 0x205dcd301, cause 'memory not mapped'

Traceback:
 1: .Call(CnativeSymbolInfo_, par, method)
 2: compiledCaller(par, method = "SANN")
 3: eval(expr, envir, enclos)
 4: eval(code, test_env)
 5: withCallingHandlers(eval(code, test_env), expectation = handle_expectation,     skip = handle_skip, warning = handle_warning, message = handle_message,     error = handle_error)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
 9: doTryCatch(return(expr), name, parentenv, handler)
10: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])
11: tryCatchList(expr, classes, parentenv, handlers)
12: tryCatch(withCallingHandlers(eval(code, test_env), expectation = handle_expectation,     skip = handle_skip, warning = handle_warning, message = handle_message,     error = handle_error), error = function(e) {}, skip = function(e) {})
13: test_code(desc, code, env = parent.frame())
14: test_that("when an RCfunction optimizes an RCfunction with SANN, the DSL and C++ behavior mostly agree",     {        nimFn <- nimbleFunction(run = function(par = double(1)) {            return(sum(par^2))            returnType(double(0))        })        nimGr <- nimbleFunction(run = function(par = double(1)) {            direction <- rnorm(length(par))            return(direction)            returnType(double(1))        })        temporarilyAssignInGlobalEnv(nimFn)        temporarilyAssignInGlobalEnv(nimGr)        nimCaller <- nimbleFunction(run = function(par = double(1),             method = character(0)) {            return(optim(par, nimFn, nimGr, method = method))            returnType(optimResultNimbleList())        })        compiledCaller <- compileNimble(nimCaller, showCompilerOutput = TRUE)        par <- c(1.2, 3.4)        expected <- nimCaller(par, method = "SANN")        actual <- compiledCaller(par, method = "SANN")        expect_equal(actual$par, expected$par)        expect_equal(actual$convergence, expected$convergence)        expect_equal(actual$value, expected$value)        expect_equal(actual$counts, unname(expected$counts))    })
An irrecoverable exception occurred. R is aborting now ...
Segmentation fault (core dumped)
