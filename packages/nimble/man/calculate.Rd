% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in Rtmpps1mQU/file481f1015d967
\name{calculate}
\alias{calculate}
\alias{calculateDiff}
\alias{getLogProb}
\alias{simulate}
\title{calculate, calculateDiff, simulate, or get the current log probabilities (densities) a set of nodes in a NIMBLE model}
\usage{
calculate(model, nodes, nodeFxnVector)
}
\arguments{
  \item{model}{A NIMBLE model, either the compiled or
  uncompiled version} \item{nodes}{A character vector
  of node names, with index blocks allowed, such as 'x',
  'y[2]', or 'z[1:3, 2:4]'}
}
\value{
calculate and getLogProb return the sum of the log
probabilities (densities) of the calculated nodes, with a
contribution of 0 from any deterministic nodes calculateDiff
returns the sum of the difference between the new and old
log probabilities (densities) of the calculated nodes, with
a contribution of 0 from any deterministic nodes. simulate
returns NULL.
}
\description{
calculate, calculateDiff, simulate, or get the current log
probabilities (densities) of one or more nodes of a NIMBLE
model and (for calculate and getLogProb) return the sum
of their log probabilities (or densities). Part of R and
NIMBLE.
}
\details{
These functions expands the nodes and then process them
in the model in the order provided. Expanding nodes means
turning 'y[1:2]' into c('y[1]','y[2]') if y is a vector
of scalar nodes. Calculation is defined for a stochastic
node as executing the log probability (density) calculation
and for a deterministic node as calculating whatever
function was provided on the right-hand side of the
model declaration. Difference calculation (calculateDiff)
executes the operation(s) on the model as calculate, but
it returns the sum of the difference between the new log
probabilities and the previous ones. Simulation is defined
for a stochastic node as drawing a random value from its
distribution, and for deterministic node as equivalent to
calculate. getLogProb simply collects the sum of the log
probabilities of nodes if they are known to have already
been calculated. These functions can be used from R or
in NIMBLE run-time functions that will be compiled. When
executed in R (including when an uncompiled nimbleFunction
is executed), they can be slow because the nodes are
expanded each time. When compiled in NIMBLE, the nodes
are expanded only once during compilation, so execution
will be much faster. It is common to want the nodes to be
provided in topologically sorted order, so that they will
be calculated or simulated following the order of the model
graph. Functions such as model$getDependencies(nodes, ...)
return nodes in topologically sorted order. They can be
directly sorted by model$topologicallySortNodes(nodes),
but if so it is a good idea to expand names first by model
$topologicallySortNodes(model$expandNodeNames(nodes))
}
\examples{
calculate(model, c('x', 'y[2:4]', 'z[2:5, 1:10]'))
}
\author{
NIMBLE development team
}

