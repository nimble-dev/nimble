% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Laplace.R
\name{Laplace_BASE}
\alias{Laplace_BASE}
\alias{nimOneLaplace1D}
\alias{nimOneLaplace}
\alias{buildLaplace}
\alias{laplace}
\alias{Laplace}
\title{Laplace approximation}
\usage{
Laplace_BASE()

nimOneLaplace1D(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

nimOneLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  optimControl,
  optimMethod,
  optimStart
)

buildLaplace(
  model,
  paramNodes,
  randomEffectsNodes,
  calcNodes,
  calcNodesNoLaplace,
  control = list()
)
}
\arguments{
\item{model}{an uncompiled NIMBLE model object.}

\item{paramNodes}{a character vector of names of parameter nodes in the model; defaults to top-level stochastic nodes.}

\item{randomEffectsNodes}{a character vector of names of unobserved (latent) nodes to integrate out using the Laplace approximation; defaults to latent stochastic nodes that depend on \code{paramNodes}.}

\item{calcNodes}{a character vector of names of nodes for calculating the log-likelihood value for Laplace approximation; defaults to nodes that depend on \code{randomEffectsNodes} as determined by \code{model$geteDependencies(randomEffectsNodes)}.
There may be deterministic nodes between \code{paramNodes} and \code{randomEffectsNodes}. These will be included in calculations automatically.}

\item{optimControl}{a list of control parameters for the inner optimization of Laplace approximation using \code{optim}. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}} for further information.}

\item{optimMethod}{optimization method to be used in \code{optim} for the inner optimization. Needed only for \code{nimOneLaplace} and \code{nimOneLaplace1D}. See 'Details' of \code{\link{optim}}.
Currently \code{nimOptim} supports: "\code{Nelder-Mead}", "\code{BFGS}", "\code{CG}", "\code{L-BFGS-B}". By default, method "\code{CG}" is used for \code{nimOneLaplace1D} and "\code{BFGS}" for \code{nimOneLaplace}.}

\item{optimStart}{choice of start values for the inner optimization. This could be \code{"last"}, \code{"last.best"}, or a vector of user provided values. \code{"last"} means the latest random effects values left in the model will be used. 
\code{"last.best"} means the latest random effects values corresponding to currently the largest Laplace likelihood will be used. By default, the initial random effects values will be used for inner optimization.}

\item{calcNodesNoLaplace}{a character vector of names of nodes for calculating the exact log-likelihood value that does not depend on any random effects; defaults to stochastic nodes that depend on \code{paramNodes} but do not depend on \code{randomEffectsNodes}.
There may be deterministic nodes between \code{paramNodes} and \code{calcNodesNoLaplace}. These will be included in calculations automatically.}

\item{control}{a named list (for \code{buildLaplace} only) that controls the behavior of the Laplace approximation. See \code{control} section below.}
}
\description{
Builds a Laplace approximation algorithm for a given NIMBLE model.
}
\section{\code{control} list}{


\code{buildLaplace} accepts the following control list elements:
\itemize{
  \item \code{split}. If TRUE (default), \code{randomEffectsNodes} will be split into conditionally independent sets if possible.
        If FALSE, \code{randomEffectsNodes} will be handled as a multivariate block.
        If a vector, \code{randomEffectsNodes} will be split by \code{split}(\code{randomEffectsNodes}, \code{control$split}).
        The last option allows arbitrary control over how \code{randomEffectsNodes} are blocked.
  \item \code{warn}. If TRUE (default), a warning is issued if \code{randomEffectsNodes}/\code{calcNodes} is provided and has extra or missing elements.
  \item \code{innerOptimControl}. See \code{optimControl}. 
  \item \code{innerOptimMethod}. See \code{optimMethod}.
  \item \code{innerOptimStart}. see \code{optimStart}.
  \item \code{outOptimControl}. A list of control parameters for maximizing the Laplace log-likelihood using \code{optim}. 
        See 'Details' of \code{\link{optim}} for further information.
}
}

\section{\code{Laplace_BASE}}{


Laplace base class, upon which specific Laplace algorithm classes are based by including \code{contains = Laplace_BASE}. This declares a list of nimbleFunctions for a single Laplace approximation.
}

\section{\code{nimOneLaplace1D}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains only one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

This function generates an object that comprises a set of methods (functions), each accomplishing one piece of many calculations to obtain the Laplace approximation and its gradient w.r.t. model parameters. 
Among these methods, six are most useful to a user:
\itemize{
  \item \code{Laplace1(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses single taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace2(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and separate components.
  \item \code{Laplace3(p)}. Laplace approximation evaluated at the parameter value \code{p}. This function uses double taping for gradient and Hessian calculations and packs everything together.
  \item \code{gr_Laplace1(p)}. Gradient of \code{Laplace1} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace2(p)}. Gradient of \code{Laplace2} w.r.t. parameters evaluated at the parameter value \code{p}.
  \item \code{gr_Laplace3(p)}. Gradient of \code{Laplace3} w.r.t. parameters evaluated at the parameter value \code{p}.
}
}

\section{\code{nimOneLaplace}}{


This function is suitable for constructing a single Laplace approximation when \code{randomEffectsNodes} contains more than one scalar node.
To use this function, one has to accurately provide inputs for all the arguments. 

The methods generated by this function are the same as \code{nimOneLaplace1D}.
}

\section{\code{buildLaplace}}{


The main function for constructing the Laplace approximation for a given model. One only needs to provide a NIMBLE model object and then the function
will determine inputs for \code{paramNodes}, \code{randomEffectsNodes}, \code{calcNodes}, and \code{calcNodesNoLaplace} and then construct the Laplace algorithm. 
Default settings are given inside the function and can be changed for all control parameters inside the \code{control} argument. 

The Laplace algorithm object contains a list of functions:
\itemize{
  \item \code{get_node_name_vec(returnParams)}. Return a list (>1) of names of parameters/random effects nodes, according to \code{returnParams = TRUE/FALSE}.
  \item \code{get_node_name_single(returnParams)}. Return the name of a single parameter/random effect node, \code{returnParams = TRUE/FALSE}.
  \item \code{set_method(method)}. Set method ID for calculating the Laplace approximation and gradient: 1 (\code{Laplace1}), 2 (\code{Laplace2}, default method), or 3 (\code{Laplace3}).
  \item \code{get_method()}. Return the method ID currently used in the algorithm. 
  \item \code{one_time_fixes()}. Fix the dimensionality issue if there is only one parameter in the model. This function is called where necessary and users do not need to run this.  
  \item \code{logLikNoLaplace(p)}. Exact log-likelihood value at parameter value \code{p}.
  \item \code{gr_logLikNoLaplace_internal(p)}. Derivative (obtained via single taping) of the exact log-likelihood function w.r.t. parameters evaluated at \code{p}.
  \item \code{gr_logLikNoLaplace(p)}. Derivative (obtained via double taping) of the exact log-likelihood function w.r.t. parameters evaluated at \code{p}.
  \item \code{Laplace(p)}. Laplace approximation to the marginal log-likelihood function at parameter value \code{p}. If a model does not include random effects, the Laplace approximation is the exact log-likelihood function. 
  \item \code{gr_Laplace(p)}. Gradient of the Laplace approximation at parameter value \code{p}.
  \item \code{p_transformed_Laplace(pTransform)}. Laplace approximation at transformed parameter value \code{pTransform}. 
        To make maximizing the Laplace likelihood unconstrained, an automated transformation via \code{\link{parameterTransform}} is performed on any parameters with value constraints.  
  \item \code{p_transformed_gr_Laplace(pTransform)}. Gradient of the Laplace approximation (with parameter transformation) w.r.t. transformed parameters, evaluated at transformed parameter value \code{pTransform}.
  \item \code{LaplaceMLE(pStart, method, hessian)}. Run maximum likelihood estimation and return results on the transformed scale if any. 
        Arguments include \code{pStart}: start value on the original scale; default to parameter values in the model, \code{method}: optimization method used in \code{optim}; default \code{BFGS}, and \code{hessian}: whether calculating the Hessian matrix or not; default to \code{TRUE}.
  \item \code{pInverseTransform(pTransform)}. Back transform the transformed parameter value \code{pTransform} to original scale.
  \item \code{derivspInverseTransform(pTransform, order)}. Derivative of the inverse transformation w.r.t. transformed parameters at \code{pTransform}. Derivative order is given by \code{order}.
  \item \code{reInverseTransform(reTrans)}. Back transform the transformed random effects value \code{reTrans} to original scale.
  \item \code{derivsreInverseTransform(reTrans, order)}. Derivative of the inverse transformation w.r.t. transformed random effects at \code{reTrans}. Derivative order is given by \code{order}.
  \item \code{optimRandomEffects(pTransform)}. Calculate the optimized random effects given transformed parameter value \code{pTransform}.
  \item \code{inverseNegHess(p, reTransform)}. Calculate the inverse of the negative Hessian matrix of the joint log-likelihood w.r.t. transformed random effects, evaluated at parameter value \code{p} and transformed random effects \code{reTransform}.
  \item \code{hess_logLik_wrt_p_wrt_re(p, reTransform)}. Calculate the Hessian matrix of the joint log-likelihood w.r.t. parameters and transformed random effects, evaluated at parameter value \code{p} and transformed random effects \code{reTransform}.
  \item \code{summary(LaplaceMLEOutput, originalScale, calcRandomEffectsStdError, returnJointCovariance)}. Summarize the maximum likelihood estimation results, given object \code{LaplaceMLEOutput} that is returned by \code{LaplaceMLE}. 
       In addition, this function accepts the following arguments:
       \itemize{
          \item \code{originalScale}. Logical. If TRUE, the function returns results for original parameters and random effects; otherwise, it returns transformed results if transformation is needed. Defaults to TRUE.
          \item \code{calcRandomEffectsStdError}. Logical. If TRUE, standard errors of random effects estimators (if any) will be calculated. Defaults to FALSE.
          \item \code{returnJointCovariance}. Logical. If TRUE, return the joint variance-covariance matrix of the estimators of random effects (if any) and parameters. Defaults to FALSE.
       } 
       This function returns a named list:
       \itemize{
          \item \code{params}. A list that contains estimates and standard errors of parameters on a specified scale, i.e. original (if \code{originalScale} is TRUE) or transformed.
          \item \code{random}. A list that contains estimates of random effects and if required their standard errors, on original/transformed scale. Standard errors are calculated following the generalized delta method of Kass and Steffey (1989).
          \item \code{vcov}. If required (i.e. \code{returnJointCovariance} is TRUE), the joint variance-covariance matrix of the estimators of random effects and parameters, on original/transformed scale. 
          \item \code{scale}. \code{original} or \code{transformed}. 
       } 
}
}

\examples{
pumpCode <- nimbleCode({ 
  for (i in 1:N){
    theta[i] ~ dgamma(alpha, beta)
    lambda[i] <- theta[i] * t[i]
    x[i] ~ dpois(lambda[i])
  }
  alpha ~ dexp(1.0)
  beta ~ dgamma(0.1, 1.0)
})
pumpConsts <- list(N = 10, t = c(94.3, 15.7, 62.9, 126, 5.24, 31.4, 1.05, 1.05, 2.1, 10.5))
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))
pumpInits <- list(alpha = 0.1, beta = 0.1, theta = rep(0.1, pumpConsts$N))
pump <- nimbleModel(code = pumpCode, name = "pump", constants = pumpConsts, 
                    data = pumpData, inits = pumpInits, buildDerivs = TRUE)
                    
# Build Laplace approximation
pumpLaplace <- buildLaplace(pump)

\dontrun{
# Compile the model
Cpump <- compileNimble(pump)
CpumpLaplace <- compileNimble(pumpLaplace, project = pump)
# Calculate MLEs of parameters
MLEres <- CpumpLaplace$LaplaceMLE()
# Calculate estimates and standard errors for parameters and random effects on original scale
allres <- CpumpLaplace$summary(MLEres, calcRandomEffectsStdError = TRUE)
}

}
\references{
Kass, R. and Steffey, D. (1989). Approximate Bayesian inference in conditionally independent hierarchical models (parametric empirical Bayes models). \emph{Journal of the American Statistical Association}, 84(407), 717–726.

Skaug, H. and Fournier, D. (2006). Automatic approximation of the marginal likelihood in non-Gaussian hierarchical models. \emph{Computational Statistics & Data Analysis}, 56, 699–709.
}
\author{
Wei Zhang, Perry de Valpine
}
