% Generated by roxygen2 (4.0.1): do not edit by hand
\docType{class}
\name{modelBaseClass-class}
\alias{checkConjugacy}
\alias{getDependencies}
\alias{getNodeNames}
\alias{getVarNames}
\alias{isData}
\alias{modelBaseClass}
\alias{modelBaseClass-class}
\alias{newModel}
\alias{resetData}
\alias{setData}
\alias{setInits}
\alias{topologicallySortNodes}
\title{Class \code{modelBaseClass}}
\description{
This class underlies all NIMBLE model objects: both R model
objects created from the return value of nimbleModel(), and
compiled model objects. The model object contains a variety
of member functions, for providing information about the
model structure, setting or querying properties of the
model, or accessing various internal components of the
model. These member functions of the modelBaseClass are
commonly used in the body of the \code{setup} function
argument to nimbleFunction(), to aid in preparation of node
vectors, nimbleFunctionLists, and other runtime inputs. See
documentation for \code{nimbleModel} for details of
creating an R model object.
}
\section{Methods}{

\describe{
\item{\code{checkConjugacy(node)}}{Determines whether or not the input node appears in a conjugate relationship, in conjunction with its stochastic dependents

Arguments:

node: A single character string representing a model node name

Details: The return value will be NULL when the input node does not appear in a conjugate relationship, or a named list when the node appears in a conjugate relationship.  In this case, the list returned is identically the control list argument required by the corresponding MCMC conjugate sampler function.}

\item{\code{getDependencies(nodes, omit = character(), self = TRUE,
  determOnly = FALSE, stochOnly = FALSE, includeData = TRUE,
  dataOnly = FALSE, includeRHSonly = FALSE, downstream = FALSE,
  returnType = "names", returnScalarComponents = FALSE)}}{Returns a character vector of the nodes dependent upon the input argument nodes, sorted topoloigically according to the model graph.  Aditional input arguments provide flexibility in the values returned.

Arguments:

nodes: Character vector of node names, with index blocks allowed, and/or variable names, the dependents of which will be returned.

omit: Character vector of node names, which will be omitted from the nodes returned.  In addition, dependent nodes subsequent to these omitted nodes will not be returned.  The omitted nodes argument serves to stop the downward search within the hierarchical model struture, and excludes the specified node.

self: Logical argument specifying whether to include the input argument nodes in the return vector of dependent nodes.  Default is TRUE.

determOnly: Logical argument specifying whether to return only deterministic nodes.  Default is FALSE.

stochOnly: Logical argument specifying whether to return only stochastic nodes.  Default is FALSE.

includeData: Logical argument specifying whether to include 'data' nodes (set via the member method setData).  Default is TRUE.

dataOnly: Logical argument specifying whether to return only 'data' nodes.  Default is FALSE.

includeRHSonly: Logical argument specifying whether to include right-hand-side-only nodes (model nodes which never appear on the left-hand-side of ~ or <- in the model code).  These nodes are neither stochastic nor deterministic, but instead function as variable inputs to the model.  Default is FALSE.

downstream: Logical argument specifying whether the downward search through the model hierarchical structure should continue beyond the first and subsequent stochastic nodes encountered, hence returning all nodes downstream of the input nodes.  Default is FALSE.

returnType: Character argument specific type object returned. Options are 'names' (returns character vector) and 'ids' (returns numeric graph IDs for model)

returnScalar Componenets: Logical argument specifying whether multivariate nodes should return full node name (i.e. 'x[1:2]') or should break down into scalar componenets (i.e. 'x[1]' and 'x[2]')

Details: The downward search for dependent nodes propagates through deterministic nodes, but by default will halt at the first level of stochastic nodes encountered.}

\item{\code{getDownstream(...)}}{Identical to getDependencies(..., downstream = TRUE)

Details: See documentation for member method getDependencies.}

\item{\code{getNodeNames(determOnly = FALSE, stochOnly = FALSE, includeData = TRUE,
  dataOnly = FALSE, includeRHSonly = FALSE, topOnly = FALSE,
  latentOnly = FALSE, endOnly = FALSE, returnType = "names",
  returnScalarComponents = FALSE)}}{Returns a character vector of all node names in the model, in topologically sorted order.  A variety of logical arguments allow for flexible subsetting of all model nodes.

Arguments:

determOnly: Logical argument specifying whether to return only deterministic nodes.  Default is FALSE.

stochOnly: Logical argument specifying whether to return only stochastic nodes.  Default is FALSE.

includeData: Logical argument specifying whether to include 'data' nodes (set via the member method setData).  Default is TRUE.

dataOnly: Logical argument specifying whether to return only 'data' nodes.  Default is FALSE.

includeRHSonly: Logical argument specifying whether to include right-hand-side-only nodes (model nodes which never appear on the left-hand-side of ~ or <- in the model code).  Default is FALSE.

topOnly: Logical argument specifying whether to return only top-level nodes from the hierarchical model structure.

latentOnly: Logical argument specifying whether to return only latent (mid-level) nodes from the hierarchical model structure.

endOnly: Logical argument specifying whether to return only end nodes from the hierarchical model structure.

returnType: Character argument specific type object returned. Options are 'names' (returns character vector) and 'ids' (returns numeric graph IDs for model)

returnScalar Componenets: Logical argument specifying whether multivariate nodes should return full node name (i.e. 'x[1:2]') or should break down into scalar componenets (i.e. 'x[1]' and 'x[2]')

Details: Multiple logical input arguments may be used simultaneously.  For example, model$getNodeNames(endOnly = TRUE, dataOnly = TRUE) will return all end-level nodes from the model which are designated as 'data'.}

\item{\code{getVarNames(logProb = FALSE, nodes)}}{Returns the names of all variables in a model, optionally including the logProb variables

Arguments:

logProb: Logical argument specifying whether or not to include the logProb variables.  Default is FALSE.

nodes: An optional character vector supplying a subset of nodes for which to extract the variable names and return the unique set of variable names}

\item{\code{isData(nodeNames)}}{Returns a vector of logical TRUE / FALSE values, corresponding to the 'data' flags of the input node names. 

Arguments:

nodeNames: A character vector of node names.  This must be entirely node names, not model variables.

Details: Returns a logical vector with the same length as the input vector.  This function may be used for testing 'data' flags, or for partitioning a list of nodes into data and non-data.}

\item{\code{newModel(data = NULL, inits = NULL, modelName = character())}}{Returns a new R model object, with the same model definiton (as defined from the original model code) as the existing model object.

Arguments:

data: A named list specifying data nodes and values, for use in the newly returned model.  If not provided, the data argument from the creation of the original R model object will be used.

inits: A named list specifying initial values, for use in the newly returned model.  If not provided, the inits argument from the creation of the original R model object will be used.

modelName: An optional character string, used to set the internal name of the model object.  If provided, this name will propagate throughout the generated C++ code, serving to improve readability.

Details: The newly created model object will be identical to the original model in terms of structure and functionality, but entirely distinct in terms of the internal values.}

\item{\code{resetData()}}{Resets the 'data' property of ALL model nodes to FALSE.  Subsequent to this call, the model will have no nodes flagged as 'data'. }

\item{\code{setData(data, warnAboutMissingNames = TRUE)}}{Sets the 'data' flag for specified nodes to TRUE, and also sets the value of these nodes to the value provided.  This is the exclusive method for specifying 'data' nodes in a model object.  When a 'data' argument is provided to 'nimbleModel()', it uses this method to set the data nodes.

Arguments:

data: A named list.  The names of list elements must correspond to model variable names.  The elements of the list must be of class numeric, with size and dimension each matching the corresponding model variable.  These numeric scalars, vectors, arrays, etc, may only contain numeric data, or NAs.

Details: If a list element contains some number of NA values, then the model nodes corresponding to these NAs will not have their value set, and will not be designated as 'data'.  Only model nodes corresponding to numeric values in the argument list elements will be designated as data.  Designating a deterministic model node as 'data' will result in an error.  Designating part of a multivariate node as 'data' and part as non-data (NA) will resilt in an error; multivariate nodes must be entirely data, or entirely non-data.}

\item{\code{setInits(inits)}}{Sets initial values (or more generally, any named list of value elements) into the model

Arguments:

inits: A named list.  The names of list elements must correspond to model variable names.  The elements of the list must be of class numeric, with size and dimension each matching the corresponding model variable.}

\item{\code{topologicallySortNodes(nodeNames)}}{Sorts the input list of node names according to the topological dependence ordering of the model structure. 

Arguments:

nodeNames: A character vector of node names, which is to be topologically sorted.

Details: This function merely reorders its input argument.  This may be inportany prior to calls such as simulate(model, nodes) or calculate(model, nodes), to enforce that the operation is performed in topological order.}
}}
\examples{
mCode <- modelCode({
mu ~ dnorm(0, 1)
x[1] ~ dnorm(mu, 1)
x[2] ~ dnorm(mu, 1)
})
Rmodel <- nimbleModel(mCode)
modelVars <- Rmodel$getVarNames()   ## returns 'mu' and 'x'
modelNodes <- Rmodel$getNodeNames()   ## returns 'mu', 'x[1]' and 'x[2]'
Rmodel$resetData()
Rmodel$setData(list(x = c(1.2, NA)))   ## flags only 'x[1]' node as data
Rmodel$isData(c('mu', 'x[1]', 'x[2]'))   ## returns c(FALSE, TRUE, FALSE)
}
\author{
Daniel Turek
}

